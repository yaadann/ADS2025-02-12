package by.it.group410901.abakumov.lesson14;

public class StatesHanoiTowerC {

    static int[] A, B, C; // Массивы для трёх стержней (башен)
    static int topA, topB, topC; // Индексы вершин стержней (указывают на следующий свободный элемент)
    static int[] maxH; // Массив для хранения максимальной высоты после каждого хода
    static int step; // Счётчик текущего шага (хода)

    // Перемещаем диск со стержня from на стержень to
    static void move(int from, int to) {
        int disk; // Переменная для хранения перемещаемого диска

        // Извлекаем диск со стержня from (операция pop)
        if (from == 0) disk = A[--topA]; // Если from = 0 (стержень A), берём диск с вершины A
        else if (from == 1) disk = B[--topB]; // Если from = 1 (стержень B), берём диск с вершины B
        else disk = C[--topC]; // Если from = 2 (стержень C), берём диск с вершины C

        // Кладём диск на стержень to (операция push)
        if (to == 0) A[topA++] = disk; // Если to = 0 (стержень A), кладём диск на A
        else if (to == 1) B[topB++] = disk; // Если to = 1 (стержень B), кладём диск на B
        else C[topC++] = disk; // Если to = 2 (стержень C), кладём диск на C

        // Записываем максимальную высоту после этого хода
        int h = topA; // Начинаем с высоты стержня A
        if (topB > h) h = topB; // Если высота стержня B больше, обновляем максимум
        if (topC > h) h = topC; // Если высота стержня C больше, обновляем максимум

        maxH[step++] = h; // Сохраняем максимальную высоту для текущего шага
    }

    // Рекурсивная функция для решения задачи Ханойских башен
    // n - количество дисков, a - исходный стержень, b - целевой стержень, c - вспомогательный стержень
    static void hanoi(int n, int a, int b, int c) {
        if (n == 0) return; // Базовый случай: если дисков нет, ничего не делаем
        hanoi(n - 1, a, c, b); // Перемещаем n-1 диск с a на c, используя b как вспомогательный
        move(a, b); // Перемещаем самый большой диск с a на b
        hanoi(n - 1, c, b, a); // Перемещаем n-1 диск с c на b, используя a как вспомогательный
    }

    public static void main(String[] args) {
        java.util.Scanner sc = new java.util.Scanner(System.in); // Читаем ввод пользователя
        int N = sc.nextInt(); // Считываем количество дисков

        int moves = (1 << N) - 1; // Вычисляем общее количество ходов: 2^N - 1

        A = new int[N]; // Инициализируем массив для стержня A
        B = new int[N]; // Инициализируем массив для стержня B
        C = new int[N]; // Инициализируем массив для стержня C

        topA = N; // На стержне A изначально N дисков
        topB = 0; // На стержне B изначально 0 дисков
        topC = 0; // На стержне C изначально 0 дисков

        // Заполняем стержень A дисками от большего к меньшему
        for (int i = 0; i < N; i++)
            A[i] = N - i; // Диск с номером N-i (самый большой диск внизу)

        maxH = new int[moves]; // Создаём массив для хранения максимальных высот
        step = 0; // Инициализируем счётчик шагов

        hanoi(N, 0, 1, 2); // Запускаем решение: перемещаем N дисков с 0 на 1, используя 2

        // Подсчитываем количество ходов для каждой максимальной высоты
        int[] cnt = new int[N + 1]; // Массив счётчиков: heights 1..N

        for (int i = 0; i < moves; i++) {
            cnt[maxH[i]]++; // Увеличиваем счётчик для соответствующей высоты
        }

        // Собираем ненулевые группы (размеры кластеров)
        int[] arr = new int[N]; // Массив для хранения размеров групп
        int p = 0; // Счётчик количества групп

        for (int h = 1; h <= N; h++) {
            if (cnt[h] > 0)
                arr[p++] = cnt[h]; // Добавляем размер группы, если она не пустая
        }

        // Сортируем пузырьком (коллекции запрещены)
        for (int i = 0; i < p; i++) {
            for (int j = 0; j + 1 < p; j++) {
                if (arr[j] > arr[j + 1]) {
                    // Меняем местами соседние элементы, если они в неправильном порядке
                    int t = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = t;
                }
            }
        }

        // Выводим размеры групп в порядке возрастания
        for (int i = 0; i < p; i++) {
            System.out.print(arr[i]); // Выводим размер группы
            if (i + 1 < p) System.out.print(" "); // Выводим пробел между числами
        }
    }
}



