package by.it.group451001.kazakov.lesson13;

import java.util.*;

public class GraphA {
    public static void main(String[] args) {
        // Создаем сканер для чтения ввода из консоли
        Scanner sc = new Scanner(System.in);
        // Читаем строку ввода и удаляем начальные и конечные пробелы
        String input = sc.nextLine().trim();

        // Создаем список смежности для представления графа
        // Ключ - вершина, значение - список вершин, в которые можно попасть из данной
        Map<String, List<String>> adj = new HashMap<>();

        // Создаем словарь для хранения полустепеней захода вершин
        // Ключ - вершина, значение - количество входящих ребер
        Map<String, Integer> indegree = new HashMap<>();

        // Разбиваем входную строку на отдельные ребра по запятым
        String[] edges = input.split(",");

        // Обрабатываем каждое ребро
        for (String e : edges) {
            // Удаляем пробелы вокруг ребра
            e = e.trim();
            // Разбиваем ребро на начальную и конечную вершины по стрелке "->"
            String[] parts = e.split("->");
            // Пропускаем некорректные записи (без стрелки)
            if (parts.length != 2) continue;

            // Извлекаем начальную вершину ребра и удаляем пробелы
            String from = parts[0].trim();
            // Извлекаем конечную вершину ребра и удаляем пробелы
            String to = parts[1].trim();

            // Инициализируем список смежности для начальной вершины, если ее еще нет
            adj.putIfAbsent(from, new ArrayList<>());
            // Инициализируем список смежности для конечной вершины, если ее еще нет
            adj.putIfAbsent(to, new ArrayList<>());
            // Инициализируем счетчик входящих ребер для начальной вершины, если ее еще нет
            indegree.putIfAbsent(from, 0);
            // Инициализируем счетчик входящих ребер для конечной вершины, если ее еще нет
            indegree.putIfAbsent(to, 0);

            // Добавляем конечную вершину в список достижимых вершин из начальной
            adj.get(from).add(to);
            // Увеличиваем счетчик входящих ребер для конечной вершины
            indegree.put(to, indegree.get(to) + 1);
        }

        // Создаем приоритетную очередь для вершин с нулевой полустепенью захода
        // Вершины автоматически сортируются в лексикографическом порядке
        PriorityQueue<String> pq = new PriorityQueue<>();

        // Проходим по всем вершинам графа
        for (String v : indegree.keySet()) {
            // Если у вершины нет входящих ребер (полустепень захода = 0)
            if (indegree.get(v) == 0) {
                // Добавляем вершину в очередь для обработки
                pq.add(v);
            }
        }

        // Создаем список для хранения результата топологической сортировки
        List<String> result = new ArrayList<>();

        // Пока в очереди есть вершины для обработки
        while (!pq.isEmpty()) {
            // Извлекаем вершину с наивысшим приоритетом (первую в лексикографическом порядке)
            String u = pq.poll();
            // Добавляем вершину в результат
            result.add(u);

            // Обрабатываем все вершины, достижимые из текущей вершины
            for (String v : adj.get(u)) {
                // Уменьшаем счетчик входящих ребер для достижимой вершины
                indegree.put(v, indegree.get(v) - 1);
                // Если достижимая вершина теперь имеет нулевую полустепень захода
                if (indegree.get(v) == 0) {
                    // Добавляем ее в очередь для дальнейшей обработки
                    pq.add(v);
                }
            }
        }

        // Выводим результат топологической сортировки, объединяя вершины через пробел
        System.out.println(String.join(" ", result));
    }
}