# Название

Оптимизация цепочек событий

# Описание

Оптимизация цепочек событий

В игре существует набор событий.  
Каждое событие может зависеть от одного или нескольких других: событие \(B\) не может быть выполнено, пока не выполнено событие \(A\).

Требуется:

1. Прочитать список событий и их зависимостей.  
2. Построить **оптимальную последовательность выполнения**, в которой:
   - все зависимости каждого события удовлетворены,
   - отсутствуют циклы (если цикл найден — вывести \(\text{"CYCLE"}\)).

---

### Формат входных данных

\[
\begin{aligned}
&N\ M \\
&A\ B \\
&C\ D \\
&\dots
\end{aligned}
\]

Где:  
- \(N\) — количество событий (нумеруются от 0 до \(N-1\)),  
- \(M\) — количество зависимостей,  
- каждая строка \(A\ B\) означает:  
  **чтобы выполнить \(B\), сначала нужно выполнить \(A\)**.

---

### Формат вывода

- Одну строку: корректный порядок выполнения событий (топологическая сортировка).  
- Если существует цикл:

\[
\text{CYCLE}
\]

---

### Пример

**Ввод:**

\[
\begin{aligned}
4\ 3 \\
0\ 1 \\
1\ 2 \\
0\ 3
\end{aligned}
\]

**Вывод:**

\[
0\ 1\ 2\ 3
\]
##ВНИМАНИЕ! Задача может иметь несколько правильных ответов!

# Краткая теория

Топологическая сортировка событий

### Ориентированный ацикличный граф (DAG) событий

Игровые события с зависимостями можно представить в виде ориентированного графа 
\( G = (V, E) \), где:

- \( V \) — множество событий (вершины),  
- \( E \) — множество зависимостей (рёбра).

Каждое ребро \( u \rightarrow v \) означает, что **событие \( v \) можно выполнить только после события \( u \)**.

---

### Топологический порядок

**Топологический порядок** — это последовательность вершин \( (v_1, v_2, \dots, v_N) \), такая что:

\[
\forall (u, v) \in E: \quad u \text{ идёт перед } v
\]

Топологический порядок существует **только если граф ацикличный** (DAG).

---

### Алгоритм Канна для топологической сортировки

1. Вычислить **входящую степень** каждой вершины:

\[
indeg(v) = \text{количество входящих рёбер у } v
\]

2. Инициализировать очередь \( Q \) всеми вершинами с нулевой входящей степенью:

\[
Q = \{ v \in V \;|\; indeg(v) = 0 \}
\]

3. Пока \( Q \) не пуста:

   1. Удалить вершину \( u \) из \( Q \) и добавить её в результат.  
   2. Для каждого соседа \( v \) вершины \( u \) (т.е. \( u \rightarrow v \)):
   
   \[
   indeg(v) := indeg(v) - 1
   \]
   
   Если \( indeg(v) = 0 \), добавить \( v \) в \( Q \).

4. Если количество вершин в результате меньше, чем \( |V| \), граф содержит **цикл**.

---

### Сложность

Пусть \( N = |V| \) и \( M = |E| \):

- **Временная сложность:** 

\[
O(N + M)
\]

- **Память:** 

\[
O(N + M)
\]

Алгоритм позволяет эффективно найти корректный порядок выполнения событий с учётом всех зависимостей.


