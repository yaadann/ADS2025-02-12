# Название

Поиск всех анаграмм в строке

# Описание

Поиск всех анаграмм в строке

## Условие задачи

Напишите программу, которая находит все начальные позиции анаграмм заданного слова в тексте.

**Формат ввода:**  
В единственной строке через пробел подаются две строки:
- `text` - строка, в которой осуществляется поиск
- `pattern` - строка, анаграммы которой нужно найти

**Формат вывода:**  
Выведите через пробел все начальные индексы (начиная с 0) в строке `text`, где начинаются анаграммы строки `pattern`. Индексы должны быть выведены в порядке возрастания. Если анаграмм не найдено, выведите символ `?`.

**Ограничения:**
- Строки содержат только строчные буквы английского алфавита
- 1 ≤ длина(`pattern`) ≤ длина(`text`) ≤ 10^5

## Примеры

### Пример 1
**Ввод:**
cbaebabacd abc

**Вывод:**
0 6

**Объяснение:**
- На индексе 0: подстрока "cba" является анаграммой "abc"
- На индексе 6: подстрока "bac" является анаграммой "abc"

### Пример 2
**Ввод:**
abab ab

**Вывод:**
0 1 2

**Объяснение:**
- Индекс 0: "ab" - анаграмма "ab"
- Индекс 1: "ba" - анаграмма "ab"  
- Индекс 2: "ab" - анаграмма "ab"

### Пример 3
**Ввод:**
hello world

**Вывод:**
?

**Объяснение:** В строке "hello" нет анаграмм слова "world"

## Примечание

Две строки являются анаграммами, если одна может быть получена из другой перестановкой букв. Например, "abc" и "cba" - анаграммы, а "abc" и "abd" - нет.

# Краткая теория

---
title: Поиск анаграмм в строке
weight: 2
authors:
- Бурштын Пётр
created: 2025
---

# Теория: Поиск анаграмм с использованием частотного анализа и скользящего окна

## Что такое анаграмма?

**Анаграмма** - это слово или фраза, образованная путем перестановки букв другого слова или фразы, с использованием всех исходных букв ровно один раз.

**Примеры анаграмм:**
- "рок" и "кор"
- "пила" и "липа" 
- "abc" и "cba"

## Ключевая идея решения

### Основное наблюдение

Два слова являются анаграммами тогда и только тогда, когда:
1. Они имеют одинаковую длину
2. Каждая буква встречается в них одинаковое количество раз

### Частотный анализ

Вместо того чтобы перебирать все возможные перестановки (что было бы очень медленно), мы можем использовать **частотный анализ**.

**Частотный массив** - это массив, где каждый элемент показывает, сколько раз соответствующая буква встречается в строке.

Для английского алфавита из 26 букв мы создаем массив из 26 элементов:
Буквы: a b c d e f ... z
Индекс: 0 1 2 3 4 5 ... 25

**Пример:** Для слова "abc" частотный массив будет:
[1, 1, 1, 0, 0, 0, ..., 0]
↑ ↑ ↑
a b c

### Алгоритм скользящего окна

Поскольку мы ищем подстроки фиксированной длины (равной длине образца), мы можем использовать эффективный алгоритм **скользящего окна**.

**Шаги алгоритма:**

1. **Инициализация:**
   - Создаем частотный массив для `pattern`
   - Создаем частотный массив для первого окна в `text` (первые L символов, где L = длина pattern)

2. **Проверка первого окна:**
   - Сравниваем два частотных массива
   - Если они равны - нашли анаграмму, запоминаем индекс 0

3. **Движение окна:**
   - Для каждой следующей позиции i от 1 до (n - L):
     - Убираем символ text[i-1] из частотного массива окна
     - Добавляем символ text[i+L-1] в частотный массив окна
     - Сравниваем частотные массивы
     - Если равны - запоминаем индекс i

4. **Формирование результата:**
   - Если найдены индексы - выводим их через пробел
   - Если индексы не найдены - выводим символ `?`

### Визуализация работы алгоритма

Рассмотрим пример `text = "cbaebabacd"`, `pattern = "abc"`:
Шаг 0: Окно [0-2] = "cba"
patternFreq: [a:1, b:1, c:1, ...]
windowFreq: [a:1, b:1, c:1, ...] → СОВПАДАЕТ! Индекс 0 в ответ

Шаг 1: Окно [1-3] = "bae"
Убираем 'c', добавляем 'e'
windowFreq: [a:1, b:1, c:0, e:1, ...] → НЕ СОВПАДАЕТ

...
Шаг 6: Окно [6-8] = "bac"
windowFreq: [a:1, b:1, c:1, ...] → СОВПАДАЕТ! Индекс 6 в ответ

Результат: найденные индексы 0 и 6 → вывод "0 6"

### Формат вывода

- Если найдены анаграммы: индексы выводятся через пробел в порядке возрастания
- Если анаграммы не найдены: выводится символ `?`

### Сложность алгоритма

- **Время:** O(n), где n - длина текста
- **Память:** O(1) - используем фиксированные массивы размером 26

Это значительно эффективнее наивного подхода O(n × L), который бы перебирал все подстроки и для каждой проверял, является ли она анаграммой.


