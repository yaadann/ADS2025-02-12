# Название

Поиск множественных подстрок в строке (алгоритм Ахо–Карасика)

# Описание

Поиск множественных подстрок в строке (алгоритм Ахо–Карасика)

## Условие задачи

Разработать программу для поиска нескольких подстрок (шаблонов) в длинной строке (геноме) с использованием алгоритма **Ахо–Карасика**. Программа должна находить **все вхождения** каждого шаблона и возвращать их позиции в исходной строке.

Особенности:

- Строка (геном) состоит из символов `A`, `C`, `G`, `T`.
- Множество шаблонов (мутаций) может содержать от нескольких до сотен элементов.
- Должна учитываться **нумерация позиций с нуля** (0-based indexing).
- Алгоритм должен работать эффективно, даже для больших геномов (например, длиной >1 млн символов).

### Входные данные

1. **Геном:** строка из символов `A`, `C`, `G`, `T`.
2. **Мутации:** массив строк, каждая строка — последовательность символов `A`, `C`, `G`, `T`, которую нужно найти в геноме.

### Выходные данные

Для каждого шаблона возвращается список всех **индексов начала вхождения** в геноме.

Пример:

Геном: "AGCTTTGCAAGCTTCGTAA"

Мутации: ["AGCTT","TTGCA","CGTAA"]

Результат:
AGCTT → [0, 9]
TTGCA → [4]
CGTAA → [13]


## Краткая теория

Алгоритмы, использующие хеширование, имеют один неприятный недостаток — они недетерминированные. Если бесконечно генерировать примеры, то рано или поздно выпадет случай, где два разных объекта дадут один и тот же хеш. Это называется коллизией.

В биоинформатике это может выступить особенно болезненно. Например, представим, что мы ищем количество различных фрагментов ДНК в длинном геноме. Если хеширование даст сбой — мы перепутаем две разные последовательности, и анализ даст неверный результат.

Приведём пример: нам требуется реализовать программу, которая определяет,
является ли данная последовательность ДНК **мутацией** другой последовательности.
Под мутацией понимается наличие **не более одной ошибки**:
- одна **замена** нуклеотида,
- или одна **вставка**,
- или одно **удаление**.

---

##Теоретическое введение

Молекула ДНК состоит из четырёх типов нуклеотидов:
$$
\text{Alphabet} = \{ A,\; C,\; G,\; T \}
$$
Пусть даны две строки: 
$
S_1\quad\text{и}\quad S_2,
$

Требуется определить:
$$
\text{mutated}(S_1, S_2) = 
\begin{cases}
\text{true}, & \text{если строки отличаются не более чем на одну операцию},\\[4pt]
\text{false}, & \text{иначе}.
\end{cases}
$$

Алгоритм Ахо-Корасик строит **префиксное дерево (Trie)** для всех шаблонов (например, известных фрагментов ДНК), а затем дополняет его:

1. **Суффиксные ссылки (failure links)** — позволяют быстро перейти к наибольшему возможному совпадающему префиксу, если текущий путь не совпадает с текстом.
2. **Автоматные переходы** — дают возможность после чтения каждого символа определить состояние автомата (какой префикс совпадает с текстом).

Это позволяет обрабатывать длинный текст **за время O(|текст| + суммарная длина шаблонов)**, независимо от количества шаблонов.
---

### Разрешённые операции

1. **Замена**  
   Один нуклеотид изменён:
   $$
   ACGT \rightarrow AGGT
   $$

2. **Вставка**
   $$
   ACGT \rightarrow ACGGT
   $$

3. **Удаление**
   $$
   ACGT \rightarrow AGT
   $$

---

### Основные шаги алгоритма

1. **Построение Trie**  

   Все шаблоны (фрагменты ДНК) вставляются в дерево. Каждая вершина соответствует префиксу одного или нескольких шаблонов.

2. **Построение суффиксных ссылок**  

   Для вершины `v` суффиксная ссылка `link(v)` ведёт к вершине, которая соответствует **наибольшему префиксу** другого шаблона, совпадающему с суффиксом строки, соответствующей `v`.

   Формула:
   $$
   link(v) = \delta(link(v.\text{parent}), v.\text{char})
   $$

3. **Автоматные переходы**  

   Автоматный переход `go(v, c)` ведёт в вершину, соответствующую максимальному принимаемому бором суффиксу строки `v + c`.

   Правила:
   - Если прямого перехода нет, используем суффиксную ссылку.
   - Если переход есть, идём в эту вершину.

4. **Обход текста**  

   Каждый символ текста обрабатывается за константное время через автоматные переходы.  
   Если текущее состояние терминальное, найдено совпадение.

### Алгоритм проверки

Логика работы функции:

1. Если длины строк равны — проверяем **одну замену**.
2. Если длины отличаются на 1 — проверяем **одну вставку/удаление**.
3. Иначе — сразу `false`.

Формально:
$$
|\,|S_1| - |S_2|\,| > 1 \;\Rightarrow\; \text{false}
$$

