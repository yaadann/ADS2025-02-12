# Название

Быстрая сортировка

# Описание

Вы абсолютно правы! Вот исправленная версия в правильном формате Markdown:

# Быстрая сортировка

## Алгоритм

Быстрая сортировка (Quick Sort) - это эффективный алгоритм сортировки, использующий стратегию "разделяй и властвуй". Алгоритм выбирает опорный элемент и разбивает массив на две части: элементы меньше опорного и элементы больше опорного, затем рекурсивно сортирует обе части.

## Реализация

```java
public class Main {

    // Main quick sort function
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            // Find the partition point
            int pivotIndex = partition(arr, low, high);

            // Recursively sort elements before and after the pivot element
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }

    // Array partitioning function
    private static int partition(int[] arr, int low, int high) {
        // Select the pivot element (last element)
        int pivot = arr[high];

        // Index of smaller element (indicates the correct position of the pivot element)
        int i = low - 1;

        for (int j = low; j < high; j++) {
            // If current element is less than or equal to pivot
            if (arr[j] <= pivot) {
                i++;
                // Swap arr[i] and arr[j]
                swap(arr, i, j);
            }
        }

        // Place the pivot element in the correct position
        swap(arr, i + 1, high);
        return i + 1;
    }

    // Helper function for swapping elements
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```
## Корректность

По индукции можно показать, что после каждого вызова функции `partition` опорный элемент занимает свою окончательную позицию в отсортированном массиве, а все элементы слева от него меньше или равны ему, и все элементы справа больше его. Рекурсивное применение этого процесса ко всем подмассивам гарантирует полную сортировку массива.

## Асимптотика

Так как алгоритм использует стратегию "разделяй и властвуй" с рекурсивными вызовами, и в худшем случае разбиение может быть несбалансированным, асимптотика составляет:

- **Худший случай**: O(n²) - когда массив уже отсортирован или все элементы равны
- **Лучший случай**: O(n log n) - когда опорный элемент делит массив пополам  
- **Средний случай**: O(n log n)

В функции `partition` происходит один проход по массиву за O(n), а рекурсивные вызовы в среднем случае имеют глубину O(log n), поэтому общая сложность O(n log n).

# Краткая теория

---
title: Быстрая сортировка
weight: 2
created: 2025
---

# Быстрая сортировка

## Алгоритм

Быстрая сортировка (Quick Sort) - это эффективный алгоритм сортировки, использующий стратегию "разделяй и властвуй". Алгоритм выбирает опорный элемент и разбивает массив на две части: элементы меньше опорного и элементы больше опорного, затем рекурсивно сортирует обе части.

## Реализация

```java
public class QuickSort {

    // Основная функция быстрой сортировки
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            // Находим точку разбиения
            int pivotIndex = partition(arr, low, high);
            
            // Рекурсивно сортируем элементы до и после опорного элемента
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }
    
    // Функция разбиения массива
    private static int partition(int[] arr, int low, int high) {
        // Выбираем опорный элемент (последний элемент)
        int pivot = arr[high];
        
        // Индекс меньшего элемента (указывает на правильную позицию опорного элемента)
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            // Если текущий элемент меньше или равен опорному
            if (arr[j] <= pivot) {
                i++;
                // Меняем местами arr[i] и arr[j]
                swap(arr, i, j);
            }
        }
        
        // Помещаем опорный элемент в правильную позицию
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    // Вспомогательная функция для обмена элементов
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

## Пример использования

```java
int[] arr = {5, 2, 1, 3, 1};
QuickSort.quickSort(arr, 0, arr.length - 1);

for (int i = 0; i < arr.length; i++)
    System.out.print(arr[i] + " ");
```

## Корректность

По индукции можно показать, что после каждого вызова функции `partition` опорный элемент занимает свою окончательную позицию в отсортированном массиве, а все элементы слева от него меньше или равны ему, и все элементы справа больше его. Рекурсивное применение этого процесса ко всем подмассивам гарантирует полную сортировку массива.

## Асимптотика

Так как алгоритм использует стратегию "разделяй и властвуй" с рекурсивными вызовами, и в худшем случае разбиение может быть несбалансированным, асимптотика составляет:

- **Худший случай**: $O(n^2)$ - когда массив уже отсортирован или все элементы равны
- **Лучший случай**: $O(n \log n)$ - когда опорный элемент делит массив пополам
- **Средний случай**: $O(n \log n)$

В функции `partition` происходит один проход по массиву за $O(n)$, а рекурсивные вызовы в среднем случае имеют глубину $O(\log n)$, поэтому общая сложность $O(n \log n)$.

### Анализ времени работы

Пусть $T(n)$ - время работы алгоритма на массиве длины $n$. Тогда:

$$
T(n) = T(k) + T(n-k-1) + O(n)
$$

где $k$ - количество элементов меньше опорного.

**Идеальный случай**: когда разбиение всегда сбалансировано ($k \approx \frac{n}{2}$):

$$
T(n) = 2T(\frac{n}{2}) + O(n)
$$

По мастер-теореме: $T(n) = O(n \log n)$

**Худший случай**: когда разбиение максимально несбалансировано ($k = 0$ или $k = n-1$):

$$
T(n) = T(n-1) + O(n)
$$

Решение этого уравнения: $T(n) = O(n^2)$

