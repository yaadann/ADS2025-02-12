# Название

Сортировка расческой

# Описание

Сетевой драйвер: Упорядочивание TCP-пакетов

Вы пишете модуль обработки данных для сетевого шлюза. Данные приходят в виде пакетов, каждый из которых имеет порядковый номер (`seq_id`).

Из-за особенностей работы сети (jitter, разные маршруты) пакеты часто приходят с небольшими нарушениями порядка. Например, вместо `1, 2, 3, 4` может прийти `1, 3, 2, 4`. Массив почти упорядочен, но не идеален.

Вам необходимо реализовать алгоритм **сортировки вставками (Insertion Sort)**.
Хотя в общем случае он работает за $O(n^2)$, на *почти отсортированных* массивах он работает за $O(n)$, что делает его быстрее, чем QuickSort или MergeSort в данном конкретном сценарии.

Напишите функцию, которая принимает буфер пакетов (массив чисел `seq_id`) и сортирует его.

### Пример

**Входные данные (буфер):**
`[101, 102, 104, 103, 105, 107, 106]`

**Выходные данные (поток):**
`[101, 102, 103, 104, 105, 106, 107]`

# Краткая теория

---
title: Сортировка вставками
weight: 1
authors:
- Сироткин Ярослав
created: 2025
---

В большинстве учебников говорят, что **Сортировка вставками** (Insertion Sort) — это медленный алгоритм с квадратичной сложностью $O(n^2)$. Это правда для случайных данных. Однако в реальной инженерии она незаменима благодаря свойству **адаптивности**.

Если массив уже частично упорядочен (количество инверсий мало), время работы алгоритма приближается к $O(n)$. Именно поэтому сложные алгоритмы вроде Timsort (используется в Python и Java) переключаются на сортировку вставками, когда разбивают данные на маленькие кусочки.

## Алгоритм (Аналогия с картами)

Представьте, что вы берете игральные карты со стола по одной и собираете их в руку:

1.  Первую карту ("пакет") просто берем в руку. Она уже отсортирована сама по себе.
2.  Берем следующую карту. Сравниваем её с теми, что уже в руке, идя справа налево.
3.  Если новая карта меньше текущей в руке — сдвигаем карту в руке вправо.
4.  Повторяем сдвиги, пока не найдем место, куда новая карта "встанет" правильно (или пока не дойдем до начала).
5.  Вставляем карту в освободившееся место.

## Формальное описание

1.  Проходим по массиву от $i = 1$ до $n-1$.
2.  Запоминаем текущий элемент: $key = A[i]$.
3.  Инициализируем индекс для сравнения: $j = i - 1$.
4.  Пока $j \ge 0$ и $A[j] > key$:
    *   Сдвигаем элемент вправо: $A[j+1] = A[j]$.
    *   Уменьшаем индекс: $j = j - 1$.
5.  Вставляем сохраненный элемент на нужное место: $A[j+1] = key$.

В случае с нашими сетевыми пакетами, внутренний цикл `while` будет выполняться очень редко (только когда пакет пришел не в том порядке).

