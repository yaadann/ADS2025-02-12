# Название

Бинарное дерево поиска

# Описание

Поиск в бинарном дереве поиска

Реализуйте поиск элементов в бинарном дереве поиска.

**Входные данные:**

- Первая строка: `n` и `n` чисел для построения дерева
    
- Вторая строка: `k` и `k` чисел для поиска
    

**Выходные данные:**  
Для каждого искомого числа выведите:

- `"found"` - если элемент найден
    
- `"not found"` - если элемент отсутствует
    

**Пример:**

text

Вход:
7 5 3 7 2 4 6 8
5 4 9 5 2 10

Выход:
found
not found
found
found
not found

**Требования:**

- Реализуйте методы `insert` и `search` для BST
    
- Обработайте все граничные случаи
    
- Все элементы в дереве гарантированно различны

# Краткая теория

title: Бинарные деревья поиска  
weight: 2  
authors:

- Галузо Павел
    created: 2025
    

---

**Бинарное дерево поиска (BST)** — это структура данных, позволяющая эффективно хранить и находить элементы. Ключевое свойство BST: для любого узла все элементы в левом поддереве меньше, а в правом — больше значения самого узла.

## Основные операции

### Поиск

Алгоритм поиска в BST рекурсивно сравнивает искомое значение с текущим узлом:

- Если значения равны — элемент найден
    
- Если искомое значение меньше — поиск продолжается в левом поддереве
    
- Если искомое значение больше — поиск продолжается в правом поддереве
    

python

def search(node, value):
    if node is None:
        return False
    if node.value == value:
        return True
    elif value < node.value:
        return search(node.left, value)
    else:
        return search(node.right, value)

### Вставка

Новые элементы всегда добавляются как листья, сохраняя свойство BST:

python

def insert(node, value):
    if node is None:
        return Node(value)
    if value < node.value:
        node.left = insert(node.left, value)
    elif value > node.value:
        node.right = insert(node.right, value)
    return node

## Сложность операций

**Высота дерева** определяет эффективность операций:

- **Лучший случай** (сбалансированное дерево): $O(\log n)$
    
- **Худший случай** (вырожденное дерево): $O(n)$
    

Высота BST зависит от порядка вставки элементов. Минимальная высота: $\lfloor \log_2 n \rfloor$, максимальная: $n-1$.

## Балансировка

Чтобы избежать вырождения в список, используются сбалансированные версии BST:

- **AVL-деревья** — строгая балансировка (разница высот поддеревьев ≤ 1)
    
- **Красно-черные деревья** — менее строгая балансировка, но эффективнее для частых модификаций
    

## Обходы дерева

- **Симметричный**(In-order): левое поддерево → узел → правое поддерево  
    _Для BST возвращает элементы в отсортированном порядке_
    
-**Прямой** (Pre-order): узел → левое поддерево → правое поддерево
    
- **Обратный** (Post-order): левое поддерево → правое поддерево → узел
    

## Практическое применение

BST используются в:

- Реализациях ассоциативных массивов (`std::map` в C++, `TreeMap` в Java)
    
- Базах данных для индексации
    
- Алгоритмах, требующих быстрого поиска и динамического добавления элементов
    

**Преимущества**: простые реализации, эффективный поиск при сбалансированности  
**Недостатки**: производительность зависит от порядка вставки, необходимость балансировки

