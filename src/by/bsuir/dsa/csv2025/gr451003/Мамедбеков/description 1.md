# Название

Угадай число

# Описание

#Угадай число
##Задание
Программа должна угадать загаданное целое число X в диапазоне от 1 до 10^9, задавая не более 30 вопросов интерактору. На каждый вопрос вида "? Y" интерактор отвечает одним из символов: '>' (если X > Y), '<' (если X < Y) или '=' (если X = Y). Как только число угадано, программа должна вывести "! X" и завершить работу.
##Замечания:
	1. Программа должна работать в интерактивном режиме: выводить вопросы на стандартный вывод и читать ответы со стандартного ввода.
	2. Убедитесь, что программа не превышает лимит в 30 вопросов.
	3. Диапазон от 1 до 1000000000, целые числа.
##Пример:
	? 500000000 
	<



# Краткая теория

---
title: Бинарный поиск
weight: 1
authors:
- Мамедбеков Эльдар
created: 2025
---

Бинарный поиск — это фундаментальный алгоритм для поиска элемента в отсортированном массиве или диапазоне. В контексте задач на угадывание числа он позволяет эффективно сужать интервал возможных значений, минимизируя количество запросов. Если диапазон слишком велик (например, от 1 до 10^9), последовательный перебор неэффективен, но бинарный поиск решает это за логарифмическое время.

В нашей задаче загаданное число X лежит в диапазоне [1, 10^9], и программа может задавать вопросы вида "? Y", получая ответы '>', '<' или '='. Цель — угадать X не более чем за 30 вопросов, что соответствует log₂(10^9) ≈ 30.

## Выбор стратегии

*Практическое правило:* всегда выбирайте середину текущего интервала для следующего вопроса. Это гарантирует, что интервал уменьшается вдвое на каждом шаге, минимизируя worst-case сценарий.

Не используйте случайные вопросы — это может привести к худшему времени. В языках программирования учитывайте переполнение при вычислении середины: вместо (left + right) / 2 используйте left + (right - left) / 2.

Для больших диапазонов (как 10^9) бинарный поиск идеален, поскольку линейный поиск потребовал бы до миллиарда операций, что неприемлемо.

## Логарифмическая сложность

> В диапазоне из N элементов бинарный поиск требует не более ⌈log₂(N)⌉ вопросов в худшем случае.

Более общее утверждение: чтобы найти элемент в отсортированном диапазоне размером N, нужно Θ(log N) операций.

**Первое доказательство** (для любителей математики). Пусть интервал начинается с размера N. После первого вопроса интервал сокращается до N/2. После второго — до N/4, и так далее. После k вопросов размер интервала ≤ N / 2^k. Когда размер становится 1, мы нашли элемент. Таким образом, k ≥ log₂(N).

Формально:

$$
k = \lceil \log_2 N \rceil
$$

Для N = 10^9:

$$
\log_2(10^9) \approx 29.897 \implies \lceil \log_2(10^9) \rceil = 30
$$

**Второе доказательство** (для любителей информатики). Каждый вопрос дает 1 бит информации (больше/меньше), а для отличия N вариантов нужно log₂(N) бит. В теории информации это минимальное количество вопросов в адаптивной стратегии.

*Примечание*: в неадаптивной стратегии (все вопросы заранее) может потребоваться больше, но здесь мы используем адаптивную.

### Бонус: «мета-задача»

Дан отсортированный массив из 100 элементов, но вы не знаете его содержимого. У вас есть доступ к "ораклу", который на запрос "? i" отвечает значением массива по индексу i. У вас 10 запросов. Найдите максимум в массиве. (Подсказка: адаптируйте бинарный поиск для поиска экстремума.)

