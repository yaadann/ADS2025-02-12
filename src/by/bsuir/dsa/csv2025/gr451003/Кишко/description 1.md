# Название

Лабиринт с телепортами

# Описание

Условие задачи
Дан лабиринт, представленный прямоугольной сеткой размером N на M. Каждая клетка может быть:

Проходимой (.)

Непроходимой (#)

Телепортом (любая строчная латинская буква от a до z)

Игрок стартует в клетке S и должен добраться до клетки E. За один ход игрок может переместиться на одну клетку вверх, вниз, влево или вправо, если она проходима или является телепортом.

Если игрок входит на клетку с телепортом, он может мгновенно (в тот же ход) переместиться на любую другую клетку с таким же буквенным обозначением телепорта. Активация телепорта не является обязательной.

Требуется найти минимальное количество ходов, необходимое для достижения цели. Если достичь цель невозможно, вывести -1.

# Краткая теория

title: Лабиринт с телепортами
weight: 3
authors:
Кишко Данила
created: 2025

Задачи на обход графов в виде лабиринтов являются классическими. Однако простая расстановка стенок может сделать задачу тривиальной. Если же добавить в лабиринт телепорты, которые мгновенно перемещают игрока из одной клетки в другую, то задача поиска кратчайшего пути перестает быть простым обходом в ширину и требует аккуратной модификации стандартного алгоритма.

Решение
Идея заключается в модификации алгоритма поиска в ширину (BFS). Ключевой момент — корректная обработка телепортов.

Моделирование графа: Представим каждую клетку как вершину графа.

Обычные рёбра: Из каждой проходимой клетки есть рёбра в соседние по сторонам проходимые клетки (вес ребра = 1 ход).

Рёбра телепортов: При попадании на клетку-телепорт X, мы можем добавить рёбра веса 0 ко всем другим клеткам с телепортом X. Однако, если делать это наивно, количество рёбер может стать очень большим (до $O(N^2 \cdot M^2)$ в худшем случае).

Оптимизация: Чтобы избежать квадратичного количества рёбер, мы можем обрабатывать телепорты "лениво". Когда BFS впервые достигает любого телепорта с буквой X, мы можем моментально "активировать" все другие телепорты X. То есть, добавить все клетки с телепортом X в очередь BFS с тем же расстоянием, но только если мы еще не обрабатывали этот тип телепорта.

Алгоритм:

Инициализируем массив dist размера N на M значением -1 (не посещена).

Создадим очередь q для BFS и поместим в неё стартовую вершину S с расстоянием 0.

Создадим булевый массив used_portal[26] для отслеживания уже активированных типов телепортов.

Пока очередь не пуста:

Извлекаем текущую клетку (x, y) с расстоянием d.

Если это клетка E, возвращаем d.

Если это телепорт с буквой ch и этот тип телепорта еще не активирован:

Помечаем used_portal[ch] = true.

Для всех клеток (tx, ty) с телепортом ch, которые еще не посещены, добавляем их в очередь с расстоянием d (вес телепорта 0).

Перебираем всех четырёх соседей (nx, ny). Если клетка проходима или является телепортом, и мы еще не посещали её, добавляем её в очередь с расстоянием d + 1.

Теория: Обход графов с нулевыми рёбрами
Стандартный алгоритм BFS находит кратчайшие пути в невзвешенном графе, где вес каждого ребра считается равным 1. Однако в данной задаче появляются рёбра с весом 0 (телепорты). Для обработки таких графов эффективно используется BFS на 0-1 графе (0-1 BFS).

0-1 BFS
Это модификация BFS, предназначенная для графов, рёбра которых имеют веса 0 или 1. Алгоритм использует двустороннюю очередь (deque) для обеспечения корректности нахождения кратчайших путей.

Принцип работы:
Используется дек вместо обычной очереди.
При обработке ребра с весом 0 вершина добавляется в начало дека.
При обработке ребра с весом 1 вершина добавляется в конец дека.

