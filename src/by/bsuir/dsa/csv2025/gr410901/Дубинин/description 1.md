# Название

Упорядочивание пар

# Описание

Упорядочивание пар

Вам дан массив пар `pairs`, где `pairs[i] = [start_i, end_i]`. Расстановка пар считается валидной, если для каждого индекса `i` (где `1 <= i < pairs.length`) выполняется условие `end_{i-1} == start_i`.

Верните валидную расстановку пар. Если существует несколько валидных расстановок, алгоритм должен вернуть расстановку, которая **лексикографически минимальна**, то есть начальная пара должна иметь **наименьший возможный первый элемент**. При равных первых элементах - наименьший второй элемент. Каждая последующая пара должна минимизировать лексикографический порядок всей последовательности.

**Примечание:** Входные данные генерируются таким образом, что существует хотя бы одна валидная расстановка пар.

## Формат ввода

Данные считываются из консоли в следующем формате:

- Первая строка содержит целое число `n` - количество пар
- Следующие `n` строк содержат по два целых числа, разделенных пробелом, представляющих `start_i` и `end_i`

### Ограничения

- 1 <= n <= 10^5
- 0 <= start_i, end_i <= 10^9
- Гарантируется, что существует валидная расстановка пар

## Формат вывода

Выведите валидную расстановку в консоль в следующем формате:

- Выведите `n` строк
- Каждая строка должна содержать два целых числа, разделенных пробелом, представляющих `start_i` и `end_i` упорядоченных пар
- Расстановка должна удовлетворять условию: для каждого i от 1 до n-1, конец (i-1)-й пары равен началу i-й пары
	  
## Примеры

### Пример 1:

**Ввод:**
5
5 1
4 5
1 3
3 2
2 4

**Вывод:**
1 3
3 2
2 4
4 5
5 1

### Пример 2:

**Ввод:**
3
1 2
2 3
3 4

**Вывод:**
1 2
2 3
3 4

# Краткая теория

Упорядочивание пар

Данная задача сводится к нахождению **лексикографически наименьшего Эйлерова пути** в ориентированном графе:

- **Вершины графа** - целые числа из пар
- **Рёбра** - ориентированные связи `start_i → end_i`
- **Условие соединения** `end_{i-1} = start_i` означает, что рёбра должны образовывать непрерывный путь

## Сложность задачи:
- **Алгоритмическая**: Поиск Эйлерова пути с лексикографическими ограничениями
- **Временная сложность**: O(n log n) из-за сортировки рёбер
- **Пространственная сложность**: O(n)

## Ключевые наблюдения:
1. **Тип графа**: 
   - Эйлеров цикл (все вершины сбалансированы: `out_degree = in_degree`)
   - Эйлеров путь (одна вершина с `out_degree = in_degree + 1`, другая с `in_degree = out_degree + 1`)

2. **Лексикографические ограничения**:
   - Начальная вершина должна быть **наименьшей возможной**
   - При обходе всегда выбирать **наименьшего соседа**
   - Гарантировать **детерминированный результат**

## Модифицированный алгоритм Хейерхолцера:
1. **Построение графа** с PriorityQueue для автоматической сортировки соседей
2. **Поиск начальной вершины** по приоритетам:
   - Вершины с `out_degree = in_degree + 1` (начало пути)
   - Наименьшая вершина с исходящими рёбрами (цикл)
3. **DFS с лексикографическим порядком** - всегда извлекать наименьшего соседа
4. **Разворот пути** и формирование результата

## Подводные камни:
- Неправильный выбор начальной вершины
- Нарушение лексикографического порядка при обходе
- Забыть обработать случай Эйлерова цикла

