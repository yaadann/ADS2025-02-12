# Название

Версионный учет остатков на складах

# Описание

Версионный учет остатков на складах

Создайте класс WarehouseVersioningC с методом main.

Дана сеть из N складов, на каждом хранится некоторое количество товара.  
Начальное состояние складов задаётся массивом целых чисел и считается версией 0.  
Далее выполняется последовательность операций, каждая из которых либо создаёт новую версию состояния, либо делает запрос к уже существующим версиям.

Необходимо реализовать поддержку следующих операций над версиями:

- ADD v i x — на основе версии v создать новую версию, в которой остаток на складе i увеличен на x.  
- MOVE v i j x — на основе версии v создать новую версию, в которой со склада i списано x, а на склад j добавлено x.  
- CLONE v — создать новую версию, полностью совпадающую с версией v.  
- SUM v l r — запрос суммы остатков на складах с номерами от l до r в версии v.  
- DELTA v1 v2 l r — запрос разницы сумм на отрезке [l, r] между версиями v2 и v1:  
  SUM(v2, l, r) − SUM(v1, l, r).

Каждая операция ADD, MOVE и CLONE создаёт ровно одну новую версию.  
Номера новых версий выдаются по порядку: начальное состояние имеет номер 0, первая созданная версия — 1, следующая — 2 и т.д.  
Операции SUM и DELTA новых версий не создают.

Сложность алгоритма должна быть не хуже O((N + Q) · log N) по времени.  
Рекомендуется использовать персистентное дерево отрезков.  
Коллекциями (ArrayList, HashMap, TreeMap и т.п.) для хранения версий пользоваться нельзя, достаточно собственных классов узлов и массивов.

***

## Формат ввода

Первая строка:  
N — количество складов, 1 ≤ N ≤ 100000.

Вторая строка:  
N целых чисел a[1..N] — начальные остатки на складах в версии 0  
(по модулю ≤ 10^9).

Третья строка:  
Q — количество операций и запросов, 1 ≤ Q ≤ 100000.

Далее идут Q строк, каждая — одна операция в одном из форматов:

- ADD v i x  
- MOVE v i j x  
- CLONE v  
- SUM v l r  
- DELTA v1 v2 l r

Гарантируется, что все номера версий v, v1, v2 корректны на момент использования.

***

## Формат вывода

Для каждой операции:

- SUM v l r  
- DELTA v1 v2 l r

выведите отдельной строкой одно целое число — ответ на запрос.

Порядок ответов должен соответствовать порядку появления запросов во входных данных.

# Краткая теория

### Персистентное дерево отрезков

- Требуется поддерживать разные версии состояния склада с быстрым доступом к любой из них.
- Все модифицирующие операции (ADD, MOVE, CLONE) создают **новую независимую версию** массива остатков.

#### Классическое дерево отрезков

- Дерево отрезков строится по начальному массиву $$ a[1..N] $$.
- Каждый узел дерева отвечает за сумму некоторого интервала склада $$ [l; r] $$.

#### Персистентность

- **Персистентное** (версионное) дерево отрезков позволяет хранить все предыдущие состояния без копирования всего массива.
- При каждом обновлении путь от корня до обновлённого листа копируется, остальные вершины переиспользуются (ссылки на них не меняются).
- Количество новых узлов на одну операцию: $$ \mathcal{O}(\log N) $$, память: $$ \mathcal{O}((N+Q)\log N) $$.

#### Пример обновления

- Для версии $$ v $$, операций вида ADD/MOVE, создаём новую версию $$ v+1 $$ путём "частичного" копирования дерева — только узлы на пути обновления.
- Все остальные версии не затрагиваются.

#### Запросы

- Сумму на отрезке $$ [l;r] $$ для любой версии можно получить как обычный запрос в дереве:
  $$
  \text{SUM}(v, l, r) = \sum_{k=l}^{r} a^{(v)}_k
  $$
  где $$ a^{(v)}_k $$ — массив остатков в версии $$ v $$.
- Разница между двумя версиями на отрезке $$ [l;r] $$:
  $$
  \text{DELTA}(v_1, v_2, l, r) = \text{SUM}(v_2, l, r) - \text{SUM}(v_1, l, r)
  $$

#### Преимущества

- Доступ к любой предыдущей версии — мгновенно.
- Обновления и запросы — $$ \mathcal{O}(\log N) $$ по времени, новой памяти — тоже $$ \mathcal{O}(\log N) $$.

