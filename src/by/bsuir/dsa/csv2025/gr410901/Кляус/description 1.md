# Название

Кратчайшие пути с возможностью удаления рёбер

# Описание

---
authors:
- Кляус Андрей
created: 2025
title: Кратчайшие пути с возможностью удаления рёбер
weight: 3
---
# Кратчайшие пути с возможностью удаления рёбер

В классической задаче о кратчайших путях мы ищем минимальное расстояние
между двумя вершинами ориентированного взвешенного графа.\
Однако что если нам разрешено **удалить** (то есть обнулить вес) до K
рёбер, встречающихся на пути?\
Такой вариант требует модифицированного алгоритма Дейкстры и аккуратного
хранения состояния.

## Формат входных данных

1.  **Строка с графом** в формате:



```
    A->B(5), B->C(3), A->C(10)
```
Каждое ребро задаётся как `X->Y(w)`, где `w` --- вес ребра.

2.  **Начальная вершина** --- строка
```
    A
```
3.  **Конечная вершина** --- строка
```
    C
```
4.  **Целое число K** --- максимальное количество рёбер, вес которых
    можно обнулить.
```
    0
```
## Требуется

Найти **минимальное расстояние от START до END**, если разрешено
обнулить (удалить) вес **до K рёбер** на пути.\
Если путь невозможен --- вывести `-1`.

Удаление ребра означает, что при движении по нему добавляется стоимость
**0**, но количество использованных «удалений» увеличивается на 1.

## Формат выходных данных

Одно число --- минимальное расстояние.

## Примеры

### Пример 1

**Ввод:**

    A->B(5), B->C(3), A->C(10)
    A
    C
    0

**Вывод:**

    8

------------------------------------------------------------------------

### Пример 2

**Ввод:**

    A->B(5), B->C(3), A->C(10)
    A
    C
    1

**Вывод:**

    0

------------------------------------------------------------------------

### Пример 3

**Ввод:**

    A->B(5), B->C(3), C->D(7), A->D(20)
    A
    D
    2

**Вывод:**

    0

------------------------------------------------------------------------

### Пример 4

**Ввод:**

    A->B(10), B->C(10), C->D(10), D->E(10)
    A
    E
    3

**Вывод:**

    10

------------------------------------------------------------------------

### Пример 5

**Ввод:**

    A->B(5), C->D(3)
    A
    D
    5

**Вывод:**

    -1

------------------------------------------------------------------------

## Подсказка

Для решения требуется модифицированный Дейкстра, где состояние --- это\
**(вершина, число использованных удалений)**,\
и для каждой вершины хранится массив расстояний размера K+1.

# Краткая теория

---
title: Кратчайшие пути с возможностью удаления рёбер 
weight: 3
authors:
- Кляус Андрей
created: 2025
---

В классической задаче о кратчайших путях требуется найти минимальное расстояние между двумя вершинами взвешенного ориентированного графа.

Однако в этом варианте разрешено **обнулить вес до $K$ рёбер**, то есть пройти по ним бесплатно.

Такой подход требует использования модифицированного алгоритма Дейкстры.

## Основная идея

Обычный Дейкстра хранит одно расстояние на вершину.

Здесь же состояние должно учитывать оставшиеся «удаления» рёбер. Мы вводим состояние

$$
(v, k),
$$

где $v$ — вершина, а $k$ — количество уже использованных обнулений.

Тогда расстояния — это массив:

$$
\text{dist}[v][k], \quad 0 \le k \le K.
$$

### Переходы

Для каждого ребра $v \to u$ с весом $w$ есть два варианта:

1. **Идти честно**

$$
\text{dist}[u][k] = \min\bigl(\text{dist}[u][k], \text{dist}[v][k] + w\bigr)
$$

2. **Удалить вес ребра (если можно)**

   Если $k < K$,

$$
\text{dist}[u][k+1] = \min\bigl(\text{dist}[u][k+1], \text{dist}[v][k]\bigr)
$$

Для обработки состояний используется приоритетная очередь, как в стандартном алгоритме Дейкстры.

## Ответ

Минимальное расстояние до конечной вершины:

$$
\min_{0 \le k \le K} \text{dist}[\text{END}][k].
$$

Если все значения бесконечность — путь не существует, необходимо вывести `-1`.

## Когда это работает эффективно

Сложность алгоритма:

$$
O\bigl((V \cdot K + E \cdot K) \log(V \cdot K)\bigr),
$$

что подходит для случаев, когда $K$ мало или умеренно (например, до нескольких сотен).

## Типичные ошибки

* Хранить только одну дистанцию на вершину — **неверно**.
* Перебирать все подмножества удаляемых рёбер — **экспоненциально дорого**.
* Изменять граф заранее — бессмысленно, так как удалённые рёбра разные для разных путей.

## Краткий пример

Если есть путь

$$
A \to B \to C, \quad w = 5, 7,
$$

и $K = 1$, то выгодно обнулить более дорогое ребро:

$$
0 + 7 = 7 \quad \text{или} \quad 5 + 0 = 5.
$$

Алгоритм автоматически найдёт оптимальный вариант с помощью состояний $(v, k)$.

