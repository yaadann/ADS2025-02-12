# Название

Анти-хеш тест

# Описание

Анти-хеш тест

Даны две строки: текст S и шаблон P.  
Нужно найти и вывести все позиции (0-based), где P встречается в S как подстрока.

### Ограничения
- 1 ≤ |P| ≤ 2000  
- 1 ≤ |S| ≤ 2⋅10⁵  
- Строки состоят из маленьких латинских букв

### Формат ввода
S
P

# Краткая теория

**Краткая теория: хеширование строк в Java — подводные камни**

В Java тип long — знаковый, поэтому простое переполнение (как в C++ с unsigned long long) здесь не работает автоматически и даёт неверные результаты.

Популярные «надёжные» константы (base = 31, 131, 29 и mod = 10⁹+7) легко атакуются: существуют заранее подготовленные строки, на которых такие хеши дают коллизии.

Безопасные способы поиска подстроки в Java:

1. Двойное хеширование  
   Считаем два независимых хеша с разными большими простыми модулями  
   (например, 1_000_000_007 и 1_000_000_009 или 998244353 и 1_000_000_007).

2. Хеширование с модулем 2⁶⁴ через BigInteger  
   (медленнее, но абсолютно безопасно).

3. Детерминированные алгоритмы без хешей  
   Z-функция или алгоритм Кнута-Морриса-Пратта — O(n+m), коллизий нет никогда.

На практике двойное хеширование — самый быстрый и достаточный по надёжности способ для задач с n ≤ 2·10⁵.

