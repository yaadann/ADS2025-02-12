# Название

Планирование задач с дедлайнами и штрафами

# Описание

Задача C: Планирование задач с дедлайнами и штрафами
Описание задачи
Вам необходимо разработать программу на языке Java, которая решает задачу оптимального планирования выполнения задач с учетом дедлайнов и штрафов за просрочку.

Практическое применение: Эта задача имеет широкое применение в управлении проектами, планировании производства, составлении расписаний и других областях, где необходимо оптимизировать порядок выполнения задач для минимизации потерь от просрочки дедлайнов.

Формулировка задачи
Дано:

Целое число 1 <= n <= 20 (количество задач)
Для каждой задачи i (от 1 до n):
Время выполнения 1 <= duration[i] <= 100
Дедлайн 1 <= deadline[i] <= 1000
Штраф за опоздание 1 <= penalty[i] <= 1000
Необходимо:

Найти оптимальный порядок выполнения всех задач, минимизирующий общий штраф
Штраф начисляется только если задача завершается после дедлайна
Формула штрафа: penalty[i] * (время_завершения - deadline[i]), если время_завершения > deadline[i]
Штраф равен 0, если время_завершения <= deadline[i]


# Краткая теория

---

title: Планирование задач с дедлайнами и штрафами

weight: 3

authors:

- Volkov

created: 2025

---

Задача оптимального планирования задач с учетом дедлайнов и штрафов — классическая задача комбинаторной оптимизации, которая имеет широкое практическое применение в управлении проектами, планировании производства и составлении расписаний.

## Постановка задачи

Дано $n$ задач, каждая задача $i$ характеризуется тремя параметрами:
- $d_i$ — время выполнения задачи
- $D_i$ — дедлайн (желательное время завершения)
- $p_i$ — штраф за единицу времени опоздания

Требуется найти такой порядок выполнения всех задач, который минимизирует общий штраф.

Штраф за задачу $i$ вычисляется следующим образом:

$$
\text{penalty}_i = \begin{cases}
0 & \text{если } t_i \leq D_i \\
p_i \cdot (t_i - D_i) & \text{если } t_i > D_i
\end{cases}
$$

где $t_i$ — время завершения задачи $i$, равное сумме времен выполнения всех задач, выполненных до неё включительно.

## Динамическое программирование с битовыми масками

Прямой перебор всех $n!$ перестановок неэффективен даже для небольших $n$. Вместо этого используем динамическое программирование с битовыми масками.

### Состояние

Обозначим через $dp[mask]$ минимальный штраф за выполнение подмножества задач, заданного битовой маской $mask$. Бит $i$ в маске равен 1, если задача $i$ включена в подмножество.

### База

$$
dp[0] = 0
$$

Пустое подмножество задач имеет нулевой штраф.

### Переход

Для каждой маски $mask$ и каждой задачи $i$, включенной в эту маску, рассмотрим подмножество без задачи $i$:

$$
mask' = mask \setminus \{i\}
$$

Время завершения задачи $i$ в текущем подмножестве:

$$
t_i = \text{finishTime}(mask') + d_i
$$

где $\text{finishTime}(mask')$ — суммарное время выполнения всех задач из подмножества $mask'$.

Штраф за задачу $i$:

$$
\text{penalty}_i = \max(0, p_i \cdot (t_i - D_i))
$$

Тогда переход имеет вид:

$$
dp[mask] = \min_{i \in mask} \left( dp[mask'] + \text{penalty}_i \right)
$$

### Восстановление ответа

Для восстановления оптимального порядка выполнения задач используем массив $parent[mask]$, который хранит индекс последней задачи, добавленной в оптимальное решение для маски $mask$.

Восстанавливаем порядок, двигаясь от полной маски $2^n - 1$ к пустой маске $0$:

```cpp
vector<int> order;
int mask = (1 << n) - 1;
while (mask > 0) {
    int last = parent[mask];
    order.push_back(last);
    mask ^= (1 << last);
}
reverse(order.begin(), order.end());
```

## Вычислительная сложность

**Время:** $O(n \cdot 2^n)$

- Количество состояний: $2^n$
- Для каждого состояния перебираем $n$ задач
- Вычисление $\text{finishTime}(mask)$ можно оптимизировать до $O(1)$ с предвычислением

**Память:** $O(2^n)$

- Массив $dp$ размера $2^n$
- Массив $parent$ размера $2^n$
- Массив $\text{finishTime}$ размера $2^n$

## Оптимизация вычисления времени завершения

Вместо пересчета $\text{finishTime}(mask)$ каждый раз, можно предвычислить его для всех масок:

```cpp
int finishTime[1 << n];
for (int mask = 0; mask < (1 << n); mask++) {
    finishTime[mask] = 0;
    for (int i = 0; i < n; i++) {
        if (mask & (1 << i)) {
            finishTime[mask] += d[i];
        }
    }
}
```

Или вычислять динамически при заполнении $dp$:

```cpp
for (int mask = 1; mask < (1 << n); mask++) {
    int totalTime = 0;
    for (int i = 0; i < n; i++) {
        if (mask & (1 << i)) {
            totalTime += d[i];
        }
    }
    // ... используем totalTime
}
```

## Практические соображения

### Ограничения на $n$

Из-за экспоненциальной сложности алгоритм применим только для небольших $n$ (обычно $n \leq 20$). Для больших значений $n$ задача становится NP-трудной, и требуются эвристические или приближенные алгоритмы.

### Переполнения

При вычислении штрафов может происходить переполнение, если $p_i \cdot (t_i - D_i)$ велико. Используйте `long long` для хранения штрафов.

### Множественные оптимальные решения

Если несколько порядков дают одинаковый минимальный штраф, алгоритм вернет один из них (зависит от порядка перебора задач).

## Связь с другими задачами

Эта задача тесно связана с:

- **Задачей о рюкзаке** — оба используют DP с битовыми масками
- **Задачей коммивояжера (TSP)** — похожая структура состояний
- **Задачей планирования на одном процессоре** — частный случай

## Применения

- **Управление проектами:** оптимизация расписания задач проекта
- **Планирование производства:** минимизация штрафов за просрочку заказов
- **Системы реального времени:** планирование задач с жесткими дедлайнами
- **Оптимизация ресурсов:** распределение задач для минимизации потерь

## Улучшения алгоритма

Для практических применений можно рассмотреть:

1. **Эвристики:** жадные алгоритмы для больших $n$
2. **Метод ветвей и границ:** отсечение заведомо неоптимальных решений
3. **Приближенные алгоритмы:** гарантированная точность в обмен на скорость
4. **Параллелизация:** независимые вычисления для разных масок


