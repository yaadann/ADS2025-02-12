# Название

Максимальный Поток

# Описание

Максимальный Поток.

**Условие Задачи (Класс FlowC):**
Создайте класс `FlowC` с методом `main`, который вычисляет **Максимальный Поток (Max Flow)** между заданными вершинами Источника (**Source**) и Стока (**Sink**) в ориентированном графе с пропускными способностями на рёбрах.

## Входные Данные

Входные данные со стандартного ввода (`System.in`):

1.  **Строка 1 (Граф):** Рёбра в формате `Узел_отправки-Узел_приёма:Пропускная_способность`. Рёбра разделены запятой (с опциональным пробелом).
2.  **Строка 2 (Source и Sink):** Имена Источника и Стока, разделённые пробелом.

## Требования к Алгоритму

* **Алгоритм:** Используйте алгоритм **Эдмондса-Карпа (Edmonds-Karp)**.
* **Остаточный граф:** При инициализации каждое прямое ребро $(u \to v)$ должно иметь соответствующее **обратное ребро** $(v \to u)$ с нулевой пропускной способностью.
* **Итерации:** В цикле `while` используйте **Обход в Ширину (BFS)** для поиска увеличивающего пути (**Augmenting Path**) от Source до Sink.
* **Обновление:** Если путь найден:
    * Определите **минимальную пропускную способность (bottleneck)** на пути.
    * Обновите остаточный граф: уменьшите ёмкость прямых рёбер и увеличьте ёмкость обратных рёбер на эту величину.

## Вывод

Программа должна вывести единственное целое число — величину **Максимального Потока** (`System.out.print()`).

## Устойчивость

Реализация должна быть устойчива к ошибкам парсинга (пробелы, разделители).

# Краткая теория

Задача о **Максимальном Потоке (Max Flow)** является краеугольной в теории графов. Она состоит в поиске максимально возможной величины потока, который можно передать от одной вершины, называемой **Источником (Source, $s$)**, до другой, называемой **Стоком (Sink, $t$)**, через сеть, рёбра которой имеют ограниченную **пропускную способность (Capacity)**.

Основной принцип: поток, входящий в любую вершину (кроме $s$ и $t$), должен быть равен потоку, выходящему из неё (закон сохранения потока).

## Алгоритм Эдмондса-Карпа

**Алгоритм Эдмондса-Карпа** — это конкретная реализация более общего **Метода Форда-Фалкерсона**. Он отличается тем, что для поиска пути использует только **Обход в Ширину (BFS)**. Использование BFS гарантирует, что каждый найденный увеличивающий путь имеет минимальное количество рёбер, что обеспечивает полиномиальное время работы алгоритма: $O(V E^2)$, где $V$ — число вершин, $E$ — число рёбер.



### Остаточный Граф ($G_f$)

Ключевым элементом алгоритма является **Остаточный Граф** ($G_f$). Этот граф отражает *доступную* пропускную способность. Он позволяет "отменять" ранее отправленный поток, чтобы найти более оптимальный общий путь, который обходит узкие места.

* **Прямое ребро ($u \to v$):** Остаточная пропускная способность $c_f(u, v) = c(u, v) - f(u, v)$, где $f(u, v)$ — текущий поток.
* **Обратное ребро ($v \to u$):** Остаточная пропускная способность $c_f(v, u) = f(u, v)$. Оно позволяет вернуть (отменить) поток, ранее отправленный по прямому ребру. При инициализации графа обратные рёбра имеют $c_f=0$.

### Итерации

Алгоритм Эдмондса-Карпа итеративно находит увеличивающие пути и обновляет остаточный граф:

1.  **Поиск увеличивающего пути:** Используя **BFS**, находится любой путь $P$ от $s$ до $t$ в $G_f$, состоящий только из рёбер с остаточной пропускной способностью $c_f(u, v) > 0$.
2.  **Определение величины потока ($\delta$):** Находится минимальная остаточная пропускная способность (bottleneck) на пути $P$:
    $$\delta = \min_{(u,v) \in P} c_f(u,v)$$
3.  **Обновление остаточного графа:** Поток $\delta$ добавляется к общему потоку, а остаточный граф обновляется:
    * **Прямое ребро:** $c_f(u, v) \leftarrow c_f(u, v) - \delta$
    * **Обратное ребро:** $c_f(v, u) \leftarrow c_f(v, u) + \delta$
4.  Цикл повторяется, пока BFS находит путь с $\delta > 0$.

## Теорема о Максимальном Потоке и Минимальном Разрезе

Сходимость алгоритма гарантируется **Теоремой о Максимальном Потоке и Минимальном Разрезе (Max-Flow Min-Cut Theorem)**.

**Разрез $(S, T)$** — это разбиение вершин графа на два непересекающихся множества $S$ и $T$, где $s \in S$ и $t \in T$.

**Пропускная способность разреза $c(S, T)$** — это сумма пропускных способностей рёбер, идущих из $S$ в $T$.

$$\text{Max Flow} = \text{Min Cut}$$

Эта теорема утверждает, что максимальный поток, который можно отправить из $s$ в $t$, всегда равен минимальной суммарной пропускной способности любого разреза, разделяющего $s$ и $t$. Нахождение минимального разреза является доказательством оптимальности максимального потока.

