# Название

k-раскраска графа

# Описание

Задача: k-раскраска графа

Дан неориентированный граф ( G = (V, E) ) с ( n ) вершинами и набором рёбер.
Также задано число ( k ).

Необходимо определить, можно ли раскрасить каждую вершину графа в один из ( k ) цветов так, чтобы выполнялось условие:

1. Никакие две смежные вершины не должны иметь одинаковый цвет.

---

## Цель

Вернуть:

* **true**, если существует корректная раскраска графа в ( k ) цветов
* **false**, если такой раскраски не существует.

---

## Формат входных данных

* В первой строке указаны два числа:
  **n** — количество вершин,
  **k** — количество доступных цветов.

* Далее следует описание рёбер графа.
  Формат может быть, например:

  * число рёбер **m**
  * затем **m** строк, каждая содержит два числа — вершины, соединённые ребром

---

## Формат выходных данных

* Одно слово: **true** или **false**.

---

## Ограничения

* **1 ≤ n ≤ 20** — количество вершин графа
* **1 ≤ k ≤ n** — количество цветов
* **0 ≤ m ≤ n·(n−1)/2** — количество рёбер
* Вершины нумеруются от **0** до **n−1**
* Граф неориентированный

---

## Пример входных данных

```
4 2
4
0 1
1 2
2 3
3 0
```

Граф представляет собой цикл из 4 вершин.
Необходимо проверить, можно ли раскрасить его двумя цветами.

---

## Пример выходных данных

```
true
```

# Краткая теория

k-раскраска графа

В задачах, связанных с графами, часто требуется различать объекты так, чтобы они не конфликтовали друг с другом.  
В случае **раскраски графа** такими объектами являются **вершины**, а конфликт возникает между вершинами, соединёнными ребром.

Раскраска графа — фундаментальная задача теории графов, лежащая в основе множества прикладных областей:  
планирования ресурсов, компиляторов, сетевого моделирования, оптимизации и др.

## Зачем раскрашивать вершины графа?

Если две вершины соединены ребром, они взаимодействуют или находятся в конфликте. Поэтому:

- **смежные вершины должны иметь разные цвета**;
- вершины, **не связанные ребром**, могут иметь одинаковый цвет.

Цвет — это условная метка. Он может обозначать:
- тип ресурса,
- время выполнения задачи,
- радиочастотный канал,
- группу объектов без конфликтов.

## Формальная модель

Пусть дан неориентированный граф

$$ G = (V, E), $$

где:
- $V$ — множество вершин,
- $E \subseteq V \times V$ — множество рёбер.

Необходимо построить отображение

$$ \mathrm{color}: V \to \{1, 2, \ldots, k\}, $$

такое, что для любого ребра $(u, v) \in E$ выполняется:

$$ \mathrm{color}(u) \neq \mathrm{color}(v). $$

Если такая раскраска существует, говорят, что граф **k-раскрашиваемый**.

## Хроматическое число графа

Минимальное количество цветов, необходимое для корректной раскраски графа, называется **хроматическим числом**:

$$ \chi(G). $$

Задача k-раскраски сводится к вопросу:

> Выполняется ли $\chi(G) \leq k$?

Если да — раскраска существует; если нет — раскрасить граф в $k$ цветов невозможно.

## Конфликты между вершинами

В данной задаче **граф конфликтов совпадает с исходным графом**:

- каждая вершина графа — объект, который нужно раскрасить,
- каждое ребро задаёт конфликт,
- конфликт означает запрет на одинаковые цвета для двух смежных вершин.

Таким образом, нет необходимости строить дополнительный граф: структура конфликтов полностью задаётся исходным графом $G$.

## Методы решения задачи

### 1. Перебор с возвратом (backtracking)

Последовательно пытаемся назначить каждой вершине один из $k$ цветов.  
Если возникает конфликт — отменяем выбор и пробуем другой цвет.

**Преимущества:**
- находит точное решение (если оно существует).

**Недостатки:**
- экспоненциальная сложность в худшем случае.

### 2. Жадные алгоритмы

Красим вершины по порядку, выбирая первый доступный цвет (который не используется у соседей).

**Плюсы:**
- очень быстрый (O(n + m) с правильной реализацией).

**Минусы:**
- может использовать больше цветов, чем $\chi(G)$ (до $\Delta+1$, где $\Delta$ — максимальная степень).

### 3. Более продвинутые алгоритмы

Используются для сложных случаев:
- DSATUR,
- точные методы ветвей и границ,
- редукция к SAT,
- метаэвристики (табу-поиск, генетические алгоритмы),
- локальный поиск и др.

## Итоговый алгоритм проверки k-раскрашиваемости (backtracking)

1. Перебрать вершины графа в некотором порядке (часто полезно упорядочить по убыванию степени).
2. Для текущей вершины попробовать назначить один из $k$ цветов.
3. Проверить, что ни один уже раскрашенный сосед не имеет такого же цвета.
4. Если цвет подходит — перейти к следующей вершине.
5. Если ни один цвет не подходит — откатиться назад (backtrack).
6. Если все вершины успешно раскрашены — граф $k$-раскрашиваемый.

## Смысл результата

- Если раскраска возможна → граф можно разложить на $k$ **независимых множеств** (цветовых классов).
- Если нет → граф слишком «плотный», потребуется больше цветов.

Таким образом, задача **k-раскраски** — это проверка возможности устранить все конфликты между вершинами, используя не более $k$ различных меток/ресурсов/групп.

