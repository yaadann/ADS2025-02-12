# Название

Динамический анализ каталога

# Описание

Динамический анализ каталога

## Описание

Система мониторинга цен интернет-магазина отслеживает N товаров. Аналитический отдел в конце дня формирует набор запросов для анализа изменений цен. Необходимо эффективно обработать все операции (в оффлайн режиме) и для каждого запроса:

- найти **медианную цену** среди всех уникальных цен на указанном диапазоне товаров,
- вывести **количество товаров на этом отрезке с ценой, большей или равной медиане**.


## Входные данные

- Первая строка содержит целое число N — количество товаров, где $1 \leq N \leq 2 \times 10^5$.
- Вторая строка содержит N целых чисел — начальные цены товаров в рублях, где $1 \leq price_i \leq 10^6$.
- Далее идет последовательность операций (не более $2 \times 10^5$), каждая в одном из следующих форматов:
    - `Update pos new_price` — заменить цену товара на позиции pos на значение new_price ($0 \leq pos < N, 1 \leq new\_price \leq 10^6$).
    - `Query L R` — посчитать медианную цену среди всех уникальных цен на отрезке [L, R] и количество товаров на этом отрезке с ценой, не меньшей медиане ($0 \leq L \leq R < N$).


## Выходные данные

Для каждого запроса `Query L R` выведите две строки:

- В первой строке — медианная цена среди всех уникальных цен на отрезке [L, R].
    - Если количество уникальных цен четное, медианой считать целочисленное среднее двух центральных.
    - Если нечетное — средний элемент среди отсортированных уникальных цен.
- Во второй строке — количество товаров на отрезке с ценой, не меньшей найденной медианы.

Результаты выводятся в порядке следования запросов. Запросы обрабатываются в оффлайн-режиме, но выводятся в том же порядке, что и во входных данных.


**Медианная цена** считается следующим образом:

- Сначала берутся уникальные цены на отрезке и сортируются по возрастанию.
- Если количество уникальных цен нечетное, медиана — элемент с индексом $n // 2$.
- Если четное, медиана — целочисленное среднее двух центральных значений: $\lfloor(\text{A}[n/2-1] + \text{A}[n/2]) / 2\rfloor$.


# Краткая теория

Алгоритм Мо

Алгоритм Мо (Mo’s algorithm) — это оффлайн-метод, позволяющий эффективно отвечать на массовые запросы к диапазонам массива (подотрезкам), если все запросы известны заранее.

## Основная идея

Обычно при sqrt-декомпозиции для каждого блока предвычисляют какие-то ответы и затем учатся быстро совмещать данные блоков. Однако, в некоторых задачах (например, запрос на моду — наибольшую частоту в диапазоне) быстрое слияние оказывается затруднено: у блока может быть слишком сложная структура для быстрого объединения. В таких случаях помогает "ленивое" движение окна: поддерживать только одну структуру данных, всегда отражающую текущий диапазон.

Mo's algorithm строится на этих принципах:

- Все запросы заранее известны (<i>off-line</i>).
- Запросы сортируются по левой границе (блоки длины около \$ \sqrt{N} \$), а внутри блоков — по правой границе.
- Последовательно двигаем <<окно>> [cur_l, cur_r] по массиву, инкрементально добавляя и убирая элементы на границах окна.

## Специфика

Несложно заметить, что в этом подходе мы никогда не пересчитываем ответы с нуля, а только добавляем или убираем по одному элементу, что позволяет поддерживать статистику инкрементально. Это удобно для таких операций, как подсчет уникальных, подсчет частот, поиск максимума/минимума, суммы и (с помощью tree/set/decomposed freq array) — медианы и моды.

## Оценка сложности

Пусть N — длина массива, Q — число запросов.

- Каждый элемент массива добавляется/убирается для каждого блока — суммарно O(N * sqrt(N))
- Перестановки левой границы — O(Q * sqrt(N))

Суммарно, асимптотика —
\$ O((N + Q) \sqrt{N}) \$
(если add/remove работают за O(1)).

***

## Советы по эффективности

- Размер блока (обычно \$ \sqrt{N} \$), но на практике стоит подобрать константу.
- Иногда используют шахматную сортировку: четные блоки сортировать по R вправо, нечетные — влево, чтобы минимизировать прыжки правой границы.
- Все операции `add` и `remove` должны быть максимально быстрыми.

***

# Расширение: 3D-Мо (Mo’s Algorithm with Updates)

Если между запросами разрешены изменения массива ("update" по точкам), классический Mo не работает.

- Каждому запросу добавляют третью координату — время t: ([l, r], t), где t — число изменений, которые нужно применить перед этим запросом.
- Запросы сортируются по (Блок времени, Блок L, R).
- Помимо движений левой/правой границ, теперь нужно аккуратно "накатывать" и "откатывать" изменения (update/undo).
- Если позиция изменения входит в текущее окно — нужно изъять старое значение, добавить новое.
- Итоговая сложность:
\$ O(N^{5/3}) \$

