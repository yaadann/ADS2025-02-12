# Название

Алгоритм Прима

# Описание

    #Алгоритм Прима

    Задание на уровень B

    Создайте class MyPrimMST, который реализует построение
    минимального остовного дерева (MST) графа с помощью
    алгоритма Прима.
    
    Граф должен храниться внутри класса в виде собственной
    структуры данных (списки смежности или матрица смежности),
    БЕЗ использования коллекций стандартной библиотеки Java
    (ArrayList, HashMap и т.п.).

    Метод toString() должен выводить рёбра MST в порядке
    возрастания стоимости, в формате:
    {u1-v1=w1, u2-v2=w2, ...}

    /////////////////////////////////////////////////////////////////////////
    //////               Обязательные к реализации методы             ///////
    /////////////////////////////////////////////////////////////////////////

                addVertex(int v)
                addEdge(int u, int v, int weight)
                vertexCount()
                edgeCount()

                runPrim(int startVertex)
                getMSTWeight()
                getMSTEdges()          // возвращает массив рёбер MST

                toString()

                clear()
                isEmpty()

                hasVertex(int v)
                hasEdge(int u, int v)

                getNeighbors(int v)    // возвращает список смежных вершин
                getEdgeWeight(int u, int v)

    /////////////////////////////////////////////////////////////////////////
    //////                      Допущения и уточнения                  ///////
    /////////////////////////////////////////////////////////////////////////

        • Граф неориентированный
        • Все веса положительные
        • Граф связный
        • MST хранится внутри объекта после вызова runPrim()

# Краткая теория

Краткая теория

Алгоритм Прима — это жадный алгоритм построения **минимального остовного дерева (Minimum Spanning Tree, MST)** в связном, взвешенном, неориентированном графе. Его цель — выбрать набор рёбер минимальной суммарной стоимости, который соединяет все вершины без циклов.

## Основная идея

Алгоритм начинает с любой стартовой вершины и пошагово расширяет дерево, каждый раз выбирая **минимальное по весу ребро**, которое соединяет уже построенную часть дерева с новой вершиной.

## Формальное описание

Пусть дан граф  
\[
G = (V, E), \quad w(e) > 0
\]

Необходимо построить остовное дерево  
\[
T \subseteq E, \quad |T| = |V|-1
\]
такое, что его суммарный вес минимален.

Алгоритм работает так:

1. Выбираем стартовую вершину  
   \[
   s \in V
   \]

2. Множество вершин MST:  
   \[
   A = \{s\}
   \]

3. Пока \(|A| < |V|\), выбираем ребро минимального веса  
   \[
   (u, v) = \arg\min_{\substack{u \in A \\ v \notin A}} w(u, v)
   \]

4. Добавляем вершину и ребро в дерево:  
   \[
   A = A \cup \{v\}, \quad T = T \cup \{(u, v)\}
   \]

## Свойства

- Алгоритм всегда строит MST.  
- Работает за  
  \[
  O(E \log V)
  \]
  если использовать приоритетную очередь,  
  или  
  \[
  O(V^2)
  \]
  при реализации на матрице смежности.

## Результат

На выходе — набор рёбер MST и его суммарный вес:  
\[
W(T) = \sum_{e \in T} w(e)
\]

Алгоритм гарантирует минимальный возможный результат.


