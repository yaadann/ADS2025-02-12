# Название

Система оптимизации маршрутов

# Описание

## Система оптимизации маршрутов

## Прикладная ситуация 
Логистическая компания обслуживает регион с тысячами пунктов выдачи и сотнями складов. 
Изменение трафика, ограничения на движение и разная скорость транспорта требуют не просто одноразового расчёта маршрутов, 
а **надёжной системы**, способной быстро давать ответы на запросы кратчайшего времени доставки в реальном времени и выдерживать большие входные размеры.

## Постановка задачи
Требуется разработать высокоэффективную программу, которая с использованием алгоритма Дейкстры будет находить кратчайшие пути в большом разрежённом графе. Такой подход позволяет быстро определять минимальное время доставки между любыми двумя точками, что критически важно для логистической компании, работающей в условиях динамически меняющегося трафика и больших объёмов данных.

Требования:
- Обработка графа с `n ≤ 200000` вершин и `m ≤ 200000` рёбер (разрежённый граф).
- Корректная работа с большими весами (каждый вес — 0 ≤ w ≤ 10^12), суммарные расстояния могут превышать 32-бит.
- Поддержка опции ранней остановки (в реальной системе часто нужен кратчайший путь до определённой цели, а не до всех вершин).
- Поддержка многопоточного чтения входа и оптимального использования памяти — код должен быть максимально эффективным.

## Формальное условие
На вход подаются:
1. `n m` — количество вершин и рёбер.
2. `m` строк: `u v w` — ребро между `u` и `v` с весом `w` (неориентированный граф, можно ездить в обе стороны).
3. `q` — количество запросов.
4. `q` строк: `s t` — запрос на кратчайший путь от `s` к `t`. Если `t = -1`, требуется вывести массив расстояний от `s` до всех вершин (в одну строку через пробел). Если `t != -1`, требуется вывести только расстояние `d(s,t)` или `-1`, если недостижимо.

Ограничения:
- `1 ≤ n ≤ 200000`, `0 ≤ m ≤ 200000`.
- `0 ≤ w ≤ 10^12`.
- `1 ≤ q ≤ 200000`.

Формат вывода:
- Для каждого запроса вывести ответ в отдельной строке. Если запрос требует полного массива расстояний — вывести `n` чисел (через пробел), несвязанным вершинам соответствует `-1`.

## Пример
**Ввод:**
```
5 6
1 2 4
1 3 2
2 3 1
2 4 5
3 4 8
4 5 3
3
1 -1
1 5
5 1
```
**Вывод:**
```
0 3 2 8 11
11
-1
```

**Пояснение:**
- Первый запрос `1 -1` — полная таблица расстояний от 1.
- Второй `1 5` — расстояние от 1 до 5 равно 11.
- Третий `5 1` — из 5 до 1 нет пути (если граф ориентирован был бы; в неориентированном примере этот запрос был бы достижим), в данном примере каскада рёбер могла бы сделаться недоступной — в тестах будет учитываться.



# Краткая теория

Теория: Алгоритм Дейкстры 

## Основная идея
Алгоритм Дейкстры ищет кратчайшие пути в графе с **неотрицательными весами**. Он последовательно выбирает вершину с минимальной текущей дистанцией и пытается улучшить расстояния до её соседей. Для больших разрежённых графов используется **приоритетная очередь**, что даёт время работы `O((n + m) log n)`.

### 1. Типы данных
- Веса до `10^12`, поэтому расстояния обязательно храним в `long`.
- Переполнение проверяем при сложении:  
  `if (dist[u] != INF && dist[u] + w < dist[v])`.

### 2. Приоритетная очередь (ленивые обновления)
- Мы не уменьшаем ключи — просто кладём новую пару `(d, v)` в очередь.
- При извлечении игнорируем записи, если `d != dist[v]`.  
  Это стандарт для больших графов.

### 3. Ранняя остановка
- Если нужен путь только `s → t`, можно завершить алгоритм в момент, когда `t` выходит из очереди.  
  Это сильно ускоряет работу при частых запросах.

### 4. Работа с разрежённым графом
- Храним граф списками смежности: массив списков рёбер.
- Для неориентированного графа добавляем ребро в обе стороны.

### 5. Мультиграф, нулевые веса, несвязность
- Можно хранить все параллельные рёбра — алгоритм сам выберет лучшее.
- Недостижимые вершины — расстояние остаётся равным `INF`.

### 6. Практические оптимизации
- Быстрый ввод: `BufferedReader`.
- Минимизация лишних объектов: использовать собственные структуры рёбер.
- Не хранить ничего лишнего — при `n, m = 200000` память критична.


