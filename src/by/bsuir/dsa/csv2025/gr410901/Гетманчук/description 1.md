# Название

АЛГОРИТМ СЖАТИЯ ХАФФМАНА

# Описание

Алгоритм сжатия Хаффмана

Цель: реализовать кодирование и декодирование текста методом.

Требования:
- Подсчитать частоты символов входной строки.
- Построить префиксное двоичное дерево Хаффмана с помощью очереди с приоритетом.
- Сгенерировать двоичные коды: левый переход — `0`, правый — `1`.
- Закодировать строку, проверив длину битовой последовательности.
- Декодировать по дереву и убедиться, что результат совпадает с исходным.
- Проверить префиксность: ни один код не является префиксом другого.

Вход:
- Строки из `data.txt`.
- Строка `S`.

Выход:
- Битовая строка `B` ( символ → код, декодированная строка `D`).

Оценка:
- Корректность построения кодов (префиксность).
- Точное декодирование: `D == S`.

Подсказки по реализации:
- Используйте приоритетную очередь для детерминированного слияния.
- Храните коды в `Map<Character, String>`.
- Обход дерева для генерации кодов с накоплением префикса.


# Краткая теория

Алгоритм сжатия Хаффмана

Идея: заменить фиксированное кодирование (по 8 бит на символ) на *переменную длину* с учётом частот. Часто встречающимся символам присваиваются более короткие коды, редким присваиваются более длинные. Чтобы декодирование было однозначным, используется *префиксное правило*: ни один код не является префиксом другого.

Оптимальность Хаффмана:
- Пусть алфавит имеет символы \( \{s_i\} \) с вероятностями \( p_i \).
- Длины кодов \( \ell_i \) выбираются так, чтобы минимизировать среднюю длину
  [ L = \sum_i p_i \, \ell_i ]

Префиксное ограничение формулируется неравенством Крафта–Макмиллана:
- [ sum_i 2^{-\ell_i} \le 1 ]

Построение дерева Хаффмана:
1. Подсчитайте частоты \( f_i \) всех символов.
2. Поместите каждый символ в узел приоритетной очереди с ключом \( f_i \).
3. Повторяйте, пока не останется один узел:
   - Извлеките два узла с минимальной частотой \( a, b \).
   - Создайте родителя с частотой \( a+b \), левым и правым потомком.
   - Верните родителя в очередь.
4. Обход дерева: левый переход — бит `0`, правый — `1`.

Свойства:
- Коды префиксны, декодирование однозначно (по пути от корня до листа).
- Суммарная длина закодированной строки:
  [ |B| = \sum_i f_i \cdot \ell_i ]
- Временная сложность построения дерева для \( m \) различных символов:
  [ O(m \log m) ]


