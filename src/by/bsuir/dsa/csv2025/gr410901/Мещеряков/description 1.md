# Название

Поиск подстроки с пропусками и перестановками

# Описание

Поиск подстроки с пропусками и перестановками

---

## Условие задачи

Даны:

* строка **s** — текст (`1 ≤ |s| ≤ 2 * 10^5`);
* строка **p** — шаблон (`1 ≤ |p| ≤ 2 * 10^5`).

Шаблон `p` состоит из трёх типов символов:

* обычные буквы `'a'`–`'z'` — **эти буквы вместе образуют одну анаграммную группу** (т.е. их порядок внутри совпадения может быть любым, но мульти-множество этих букв должно совпадать);
* символ `?` — соответствует **любой одиночной букве**, но позиционно: на этой конкретной позиции шаблона может быть любой символ строки;
* группы вида `{abc}` — множество допустимых символов для данной позиции; на этой позиции символ строки обязан принадлежать этому множества.

Мы ищем все индексы `i` (0‑based), такие что подстрока `s[i … i + |p| - 1]` удовлетворяет шаблону `p` при следующих строгих правилах:

1. **Анаграммная группа.** Все обычные символы шаблона (все символы `a`–`z`, которые находятся вне фигурных скобок и не равны `?`) рассматриваются как набор (мультимножество). Подстрока на соответствующих позициях должна содержать ровно те же буквы (в любом порядке). То есть фиксированные буквы шаблона задают только частоты символов, а не порядок.
2. **Позиционные совпадения.** Каждая позиция шаблона, где стоит `?` или `{…}`, должна совпадать с символом строки по индексу: `?` принимает любой символ, `{...}` принимает только символы из соответствующего множества.
3. Никакая буква из анаграммной группы не привязана к конкретной позиции — они могут распределяться по позициям шаблона, которые не заняты позиционно заданными множества{…} или `?`.

Выведите все начала совпадений (индексы `i`) в возрастающем порядке, разделённые пробелом. Если совпадений нет — выведите пустую строку.

---

## Формат ввода

Вход содержит две строки:

1. `s` — текст.
2. `p` — шаблон.

Примеры чтения: стандартный ввод, две строки.

---

## Ограничения

* `1 ≤ |s|, |p| ≤ 2 * 10^5`;
* Все символы в `s` и в шаблоне (внутри множеств и вне их) — строчные латинские буквы `a`–`z`, а также символы `?`, `{`, `}` и запятые или перечисления внутри `{}` (запятые необязательны; допустимы символы подряд, например `{abc}`).
* Шаблон гарантированно корректно оформлен: каждая `{` имеет соответствующую `}`.

---

## Пример

Вход:

```
s = "cbaebabacd"
p = "abc"
```

Шаблон состоит только из обычных символов `a`, `b`, `c`. Тогда все три этих символа формируют анаграммную группу — мы ищем любую перестановку `a,b,c` в каждой подстроке длины 3.

Выход:

```
0 6
```

---

## Пояснение к примеру

Подстроки длины 3, которые являются перестановками `a,b,c`: `cba` (начиная с 0) и `bac` (начиная с 6). Они удовлетворяют: мульти-множество букв совпадает с множеством букв шаблона. Остальные окна содержат другие буквы.

---

## Формат выходных данных

Вывести на одной строке через пробел все индексы (0‑based) начала совпадений в порядке возрастания. Если совпадений нет — вывести пустую строку (или просто перевести строку).

---


# Краткая теория

1. Разберём шаблон на последовательность *групп* (одна группа — одна позиция шаблона): каждый элемент — либо `?`, либо множество `{…}`, либо фиксированная буква (которая входит в анаграммную группу).
2. Пусть длина шаблона равна `m`, длина текста `n`.
3. Если число позиций `m` больше `n` — ответ пуст.
4. Выделим из шаблона все позиции типа «фигурная скобка» `{…}` и `?` — они проверяются позиционно и не участвуют в частотных суммах анаграммы. Все остальные позиции (буквы `a`–`z`) — это наша анаграммная группа; составим массив `need[26]` — сколько раз каждая буква в ней встречается.
5. Для каждого сдвига `left` от `0` до `n - m` проверяем:

   * для каждой позиции `i` такого окна, если в шаблоне на `i` стоит `{…}`, то проверяем принадлежность `s[left+i]` к множеству; при несовпадении — это окно отвергается;
   * на позициях с `?` — ничего не требуем;
   * на позициях, относящихся к анаграммной группе, считаем частоты букв в окне (массив `have[26]`);
   * если `have == need` (по всем 26 буквам), то окно подходит.

Эта логика корректна, потому что `?` не вносит конкретных требований, `{…}` фиксирует требование по индексу, а все оставшиеся позиции должны ровно составить мультимножество букв из шаблона.

