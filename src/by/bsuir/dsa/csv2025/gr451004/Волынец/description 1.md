# Название

Поиск коллизий хэш-функций

# Описание

Сравнение хэш-функций. Поиск коллизий хэш-функций

## Задача
Написать программу на **Java**, которая принимает от пользователя две строки и сравнивает их хэши, вычисленные двумя разными функциями. Нужно определить, возникает ли коллизия (одинаковый хэш при разных строках).

## Требования

1. **Реализовать две хэш-функции (16 бит):**
   - **Функция A:** сумма ASCII-кодов символов строки по модулю $2^{16}$.
   - **Функция B:** алгоритм FNV-1a, использующий XOR и умножение на простое число, результат ограничить до 16 бит (`& 0xFFFF`).

2. **Алгоритм работы программы:**
   - Прочитать **две строки** из консоли.
   - Для каждой строки вычислить хэш обеими функциями.
   - Вывести хэши.
   - Сообщить, есть ли коллизия для каждой функции.

# Краткая теория

Хеширование — это процесс преобразования входных данных произвольной длины (строка, файл, объект) в выходное значение фиксированной длины (хеш-код или дайджест).  
**Цель:** создание уникального "отпечатка" данных для их быстрой идентификации, сравнения или обеспечения целостности.  

Хеш-коды используются:
- в структурах данных (например, `HashMap`, `HashSet`)
- в криптографии (например, `SHA-256`)

---

## Ключевые свойства хорошей хеш-функции

- **Детерминированность**: одна и та же входная строка всегда даёт один и тот же хеш.  
- **Эффективность**: вычисление хеша должно происходить быстро.  
- **Диффузия (Diffusion)**: изменение одного бита во входных данных должно приводить к изменению примерно половины битов в выходном хеше (эффект лавины).  
- **Конфузия (Confusion)**: связь между входными данными и выходным хешем должна быть сложной и нелинейной.  
- **Устойчивость к коллизиям**: должно быть невозможно найти две разные строки $S_1 \neq S_2$, для которых $H(S_1) = H(S_2)$.

---

## Коллизии и парадокс дней рождений

Коллизия возникает, когда две различные строки преобразуются в одно и то же хеш-значение:

$S_1 \neq S_2 \implies H(S_1) = H(S_2)$

Так как входное пространство бесконечно, а выходное конечно (например, $2^{16}$ или $2^{64}$), коллизии неизбежны по принципу Дирихле.  
Задача хорошей хеш-функции — сделать их редкими и трудными для нахождения.

### Парадокс дней рождений
Принцип показывает, насколько быстро появляются коллизии в случайном хеш-пространстве.

- Пусть $N$ — размер хеш-пространства (например, $N = 2^{16} = 65536$).  
- Вероятность найти первую коллизию превышает 50% после добавления $k$ случайных элементов, где:

$k \approx \sqrt{N}$

**Пример:**  
В 16-битном пространстве ($N=65536$) первая коллизия ожидается уже после:

$k \approx \sqrt{65536} = 256$

а не после 65536.

---

## Сравнение простых и продвинутых хеш-функций

### 1. Простая сумма ASCII (Функция A)
**Принцип:**

$H = \left(\sum \text{ASCII}(c_i)\right) \pmod{N}$

**Недостатки:**
- Плохая диффузия: порядок символов не влияет (например, "ab" и "ba" → одинаковый хеш).  
- Низкая чувствительность: замена символов, компенсирующая сумму, часто даёт коллизию.  

**Результат:** коллизии возникают гораздо раньше, чем предсказывает $\sqrt{N}$.

---

### 2. FNV-1a (Функция B)
**Принцип:**  
Использует смешивание (XOR) и умножение на специальное простое число (FNV Prime) для каждого символа.

**Преимущества:**
- Отличная диффузия: каждый бит предыдущего хеша влияет на следующий.  
- Хорошее распределение: значения равномерно распределены по пространству.  

**Результат:** коллизии возникают близко к ожидаемому значению $\sqrt{N}$.

---

## Применение
- **Структуры данных:** быстрый доступ (`HashMap`, `HashSet`).  
- **Криптография:** SHA-256, SHA-3 — защита данных, цифровые подписи.  
- **Некриптографические задачи:** FNV-1a, MurmurHash, xxHash — баланс скорости и качества.

