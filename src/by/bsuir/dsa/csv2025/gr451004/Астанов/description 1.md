# Название

Бинарный поиск: нахождение первого вхождения элемента

# Описание

 Бинарный поиск: нахождение первого вхождения элемента

## Задание

Дана непустая последовательность целых чисел, разделённых пробелами. Первое число `N` задаёт длину массива, следующие `N` чисел представляют отсортированный массив, последнее число `X` — искомый элемент.<br>
Для данной последовательности:

1. Реализовать алгоритм бинарного поиска для нахождения позиции первого вхождения элемента `X` в массиве.
2. Если элемент отсутствует в массиве, вернуть `-1`.
3. Вывести полученную позицию.

> **Замечания:**
> - массив гарантированно отсортирован по возрастанию;
> - все числа целые;
> - длина массива `N` может быть от 1 до 10^5.

## Пример

- Ввод:<br>
`5 1 3 3 5 7 3`
- Ожидаемый вывод:<br>
`1`

# Краткая теория

Бинарный поиск: нахождение первого вхождения элемента
Теория
Бинарный поиск — эффективный алгоритм для нахождения позиции элемента в отсортированном массиве. В отличие от линейного поиска, который работает за $O(n)$, бинарный поиск имеет сложность $O(\log n)$.

Алгоритм поиска первого вхождения
Пусть дан отсортированный массив $A$ длиной $n$ и целевой элемент $x$. Нам нужно найти наименьший индекс $i$, такой что $A[i] = x$.


public class BinarySearch {
    public static int binarySearchFirst(int[] arr, int x) {
        int left = 0;
        int right = arr.length - 1;
        int result = -1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;  // Защита от переполнения
            
            if (arr[mid] == x) {
                result = mid;      // Нашли возможный ответ
                right = mid - 1;   // Продолжаем искать слева
            } else if (arr[mid] < x) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return result;
    }
    
    public static void main(String[] args) {
        // Пример использования
        int[] arr = {1, 3, 3, 5, 7};
        int x = 3;
        int position = binarySearchFirst(arr, x);
        System.out.println("Первое вождение элемента " + x + ": " + position);
    }
}
Анализ сложности
Временная сложность: $O(\log n)$

Пространственная сложность: $O(1)$

Доказательство сложности: На каждом шаге алгоритма размер рассматриваемого подмассива уменьшается вдвое. Максимальное количество итераций равно $\lceil \log_2 n \rceil$.

Пример работы
Для массива $A = [1, 3, 3, 5, 7]$ и $x = 3$:


Итерация 1: left=0, right=4, mid=2, A[2]=3 → result=2, right=1
Итерация 2: left=0, right=1, mid=0, A[0]=1 < 3 → left=1
Итерация 3: left=1, right=1, mid=1, A[1]=3 → result=1, right=0
Итерация 4: left=1, right=0 → выход
Результат: 1
Ключевые особенности
Инвариант: если $x$ присутствует в массиве, то его первое вождение всегда находится в интервале $[left, right]$

Защита от переполнения: используем mid = left + (right - left) / 2 вместо (left + right) / 2

Условие выхода: left > right гарантирует, что весь массив проверен

