# Название

Задача N ферзей

# Описание

Задача N ферзей

## Задание

Задача o N ферзях — это проблема расстановки N ферзей на шахматной доске **n x n** таким образом, чтобы никакие два ферзя не атаковали друг друга.

Учитывая целое число **n**, верните *количество* различных решений задачи о N ферзях.


> **Замечания:**
> - Ферзь атакует любую клетку на той же строке, столбце или диагонали.

## Пример 1

-   Ввод:
    `4`
-   Ожидаемый вывод:
    `2`
-   Объяснение: Существует два различных решения, как показано на изображении.

## Пример 2

-   Ввод:
    `1`
-   Ожидаемый вывод:
    `1`

## Ограничения

-   `1 <= n <= 9`

---

# Краткая теория

Теоретические сведения

## Поиск с возвратом (Backtracking)

### Определение

**Поиск с возвратом** — это общий алгоритмический метод для решения задач, который систематически перебирает всех возможных кандидатов в решения. Он используется для задач, требующих нахождения *всех* (или *некоторых*) решений, в частности, для задач удовлетворения ограничений.


Основная идея заключается в том, чтобы строить решение пошагово (инкрементально). На каждом шаге мы проверяем, может ли текущий частичный кандидат быть доведён до полного решения.

1.  Если кандидат может быть расширен, мы делаем следующий шаг (рекурсивный вызов).
2.  Если на каком-то шаге мы обнаруживаем, что текущий кандидат не может привести к валидному решению (он нарушает ограничения), мы "откатываемся" (backtrack) на шаг назад и пробуем другой вариант.
3.  Если кандидат является полным и валидным решением (достигнут базовый случай рекурсии), мы его засчитываем.

### Применение к задаче N ферзей

В задаче N ферзей мы пытаемся разместить по одному ферзю в каждой строке, начиная с `row = 0`.

-   **Шаг:** Попытаться разместить ферзя в `row` (текущая строка).
-   **Кандидаты:** Перебираем все столбцы `j` от `0` до `n-1` для этой строки.
-   **Проверка ограничений:** Прежде чем разместить ферзя в `(row, j)`, мы должны проверить, "безопасно" ли это. То есть, ни один ранее размещённый ферзь (в строках `0`...`row-1`) не должен атаковать эту клетку.

### Оптимизация проверки безопасности

Для быстрой проверки безопасности (вместо того, чтобы каждый раз заново просматривать всех ранее размещённых ферзей) мы можем использовать вспомогательные массивы для отслеживания занятых линий:

-   `col[n]`: Хранит информацию о занятых **столбцах**.
    -   `col[j] == 1`, если столбец `j` занят.
-   `topRight[2*n-1]`: Хранит информацию о занятых **побочных диагоналях** (анти-диагоналях).
    -   Для клетки `(i, j)` индекс этой диагонали — `i+j`.
-   `topLeft[2*n-1]`: Хранит информацию о занятых **главных диагоналях**.
    -   Для клетки `(i, j)` индекс этой диагонали — `i-j`.
    -   Чтобы избежать отрицательных индексов, используется смещение: `i-j + n-1`.

При рекурсивном вызове `help(i, ...)` (где `i` — номер строки):

1.  Мы перебираем столбец `j` от `0` до `n-1`.
2.  **Проверяем**, свободна ли ячейка:
    `if ((col[j] == 0) && (topLeft[i-j+n-1] == 0) && (topRight[i+j] == 0))`
3.  Если да:
    -   "Ставим" ферзя (помечаем все три массива как `1`).
    -   Рекурсивно вызываем `help(i+1, ...)` для следующей строки.
    -   Прибавляем результат к `count`.
    -   "Убираем" ферзя (**backtrack**): помечаем все три массива обратно как `0`, чтобы попробовать следующий столбец `j`.
4.  **Базовый случай:** Если `i == n` (мы успешно разместили ферзей во всех `n` строках), мы нашли одно валидное решение и возвращаем `1`.

---

