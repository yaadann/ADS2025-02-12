# Название

Слияние двух BST в сбалансированное дерево

# Описание

#Слияние двух BST в сбалансированное дерево

Даны два непустых бинарных дерева поиска (BST). Вам необходимо объединить их в одно сбалансированное бинарное дерево поиска.

Сбалансированное дерево в данном контексте определяется как дерево, в котором глубина левого и правого поддеревьев каждого узла отличается не более чем на 1.

Напишите функцию

public TreeNode mergeTreesToBalanced(TreeNode root1, TreeNode root2) {
    // Ваша реализация
}

Входные данные:

    root1: Корень первого BST.

    root2: Корень второго BST.

Выходные данные:

    Корень нового сбалансированного BST, содержащего все узлы из обоих исходных деревьев.

Примечания:

    Исходные деревья могут быть несбалансированными.

    Деревья могут содержать дубликаты. В этом случае все дубликаты должны быть сохранены в итоговом дереве.

    Структура TreeNode определена стандартным образом:

public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

Пример:

Вход:
Дерево 1:      2     Дерево 2:      5
              / \                  /
             1   3                4

Выход (одна из возможных сбалансированных структур):
        3
       / \
      2   5
     /   /
    1   4


# Краткая теория

Бинарное дерево поиска (BST)

Бинарное дерево поиска — это структура данных, в которой каждый узел имеет не более двух потомков и выполняется свойство упорядоченности:

    Все узлы в левом поддереве имеют значения меньшие, чем значение родительского узла

    Все узлы в правом поддереве имеют значения большие, чем значение родительского узла

In-order обход

Для BST in-order обход (левый-корень-правый) возвращает узлы в отсортированном порядке:
text

void inOrder(TreeNode node, List<Integer> list) {
    if (node == null) return;
    inOrder(node.left, list);
    list.add(node.val);
    inOrder(node.right, list);
}

Сбалансированные деревья

Дерево считается сбалансированным, если для каждого узла выполняется:
∣height(left)−height(right)∣≤1
∣height(left)−height(right)∣≤1

где heightheight — высота поддерева.

