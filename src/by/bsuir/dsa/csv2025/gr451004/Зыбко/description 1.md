# Название

Система автоматической цензуры текста с использованием алгоритма Ахо-Корасик

# Описание

Система автоматической цензуры текста с использованием алгоритма Ахо-Корасик

## Цель задания

Разработать систему автоматической цензуры текста, которая эффективно находит и маскирует запрещенные слова с использованием алгоритма Ахо-Корасик для поиска множества паттернов за линейное время.

## Техническое задание

### Требования к функциональности

1. **Добавление запрещенных слов** в словарь системы
2. **Построение автомата** на основе добавленных слов с использованием BFS-подхода
3. **Поиск запрещенных слов** в произвольном тексте
4. **Маскировка найденных слов** заменой на символ '-'
5. **Поддержка латинского алфавита** (a-z)

### Алгоритмические требования

- Реализация префиксного дерева (бора) для хранения запрещенных слов
- Вычисление суффиксных ссылок для эффективных переходов
- Реализация автоматных переходов для обработки несовпадений
- Обеспечение временной сложности O(n + m), где:
  - n - длина текста
  - m - суммарная длина всех запрещенных слов

# Краткая теория

---
title: Алгоритм Ахо-Корасик
weight: 2
author:
- Зыбко Андрей
created: 2025
---

Алгоритм Ахо-Корасик решает задачу поиска множества подстрок в тексте. Если решать задачу «в лоб», проверяя каждое слово отдельно, то получается сложность $O(m \cdot n)$, где $m$ — суммарная длина слов, а $n$ — длина текста. Алгоритм Ахо-Корасик позволяет решить эту задачу за $O(n + m + k)$, где $k$ — общее количество вхождений.

Событие, когда алгоритм находит вхождение подстроки в текст, называется *совпадением*. В задаче цензурирования каждое такое совпадение приводит к замене соответствующего слова на звёздочки.

## Построение автомата

*Практическое правило:* для алфавита размера $k$ каждая вершина содержит $k$ указателей на детей. В моей реализации используется английский алфавит ($k = 26$).

Основная идея — построить по набору запрещённых слов *префиксное дерево* (бор), а затем дополнить его *суффиксными ссылками* и *автоматными переходами*.

### Суффиксные ссылки

Для вершины $v$, соответствующей строке $s$, суффиксная ссылка $link(v)$ ведет в вершину, соответствующую **наибольшему собственному суффиксу** $s$, который также является префиксом некоторого запрещённого слова.

**Рекуррентная формула:**
$$
link(v) = 
\begin{cases} 
root & \text{если } v = root \text{ или } parent(v) = root \\
\delta(link(parent(v)), char(v)) & \text{иначе}
\end{cases}
$$

### Автоматные переходы

Функция $\delta(v, c)$ возвращает вершину, соответствующую наибольшему принимаемому бором суффиксу строки $v + c$:

$$
\delta(v, c) = 
\begin{cases}
to[v][c] & \text{если переход существует} \\
root & \text{если } v = root \\
\delta(link(v), c) & \text{иначе}
\end{cases}
$$

## Оптимизация через BFS

Хотя суффиксные ссылки можно вычислять лениво (через мемоизацию), в моей реализации используется BFS-подход:

```java
public void buildAutomatonBFS() {
    Queue<Vertex> queue = new LinkedList<>();
    root.link = root;
    for (int i = 0; i < 26; i++) {
        if (root.to[i] != null) {
            root.to[i].link = root;
            queue.add(root.to[i]);
        } else {
            root.go[i] = root;
        }
    }
    while (!queue.isEmpty()) {
        Vertex v = queue.poll();
        for (int i = 0; i < 26; i++) {
            if (v.to[i] != null) {
                Vertex child = v.to[i];
                child.link = go(v.link, i);
                queue.add(child);
            }
        }
    }
}

