# Name

Finding a Substring Using Prefix Functions

# Task

Задание: Поиск подстроки с помощью префикс-функции

## Цель
Реализовать алгоритм поиска подстроки (образца) в строке (тексте), используя префикс-функцию и алгоритм Кнута-Морриса-Пратта (KMP).

## Формальная постановка задачи

Напишите на Java метод `findAllOccurrences`, который принимает две строки: `text` (текст, в котором выполняется поиск) и `pattern` (образец, который нужно найти). Метод должен вернуть список индексов всех позиций в `text`, начиная с которых образец `pattern` входит как подстрока.

Если вхождений не найдено, должен быть возвращен пустой список.

## Алгоритм

Алгоритм состоит из двух основных шагов:

1.  **Вычисление префикс-функции** для образца `pattern`.
    *   **Префикс-функция** `pi[i]` для строки `pattern` — это длина наибольшего собственного суффикса подстроки `pattern[0..i]`, который одновременно является её префиксом.
    *   Собственный означает, что суффикс не совпадает со всей строкой.
    *   Формально: `pi[i] = max{k | k < i+1 и pattern[0..k-1] == pattern[i-k+1..i]}`.

2.  **Поиск образца в тексте** с использованием вычисленной префикс-функции.
    *   Используется тот же принцип, что и при вычислении префикс-функции, но теперь мы ищем образец `pattern` в тексте `text`.

## Требования к реализации

*   Сигнатура метода должна быть:
    ```java
    public static List<Integer> findAllOccurrences(String text, String pattern)
    ```
*   Для хранения результата используйте `ArrayList<Integer>`.
*   Реализуйте вспомогательный метод `computePrefixFunction` для вычисления префикс-функции.
    ```java
    private static int[] computePrefixFunction(String pattern)
    ```
*   Учтите краевые случаи:
    *   Если `pattern` пустая строка, каждую позицию в `text` (включая 0) можно считать вхождением? В данном задании, для пустого образца верните пустой список.
    *   Если `pattern` длиннее `text`, сразу возвращайте пустой список.

## Примеры

```java
// Пример 1
String text1 = "ababcababa";
String pattern1 = "ababa";
// Префикс-функция для "ababa": [0, 0, 1, 2, 3]
List<Integer> result1 = findAllOccurrences(text1, pattern1);
// Ожидаемый результат: [5]
// Объяснение: "ababa" найдена начиная с индекса 5: "ababc[ababa]"

// Пример 2
String text2 = "hello world";
String pattern2 = "l";
List<Integer> result2 = findAllOccurrences(text2, pattern2);
// Ожидаемый результат: [2, 3, 9]

// Пример 3
String text3 = "abc";
String pattern3 = "d";
List<Integer> result3 = findAllOccurrences(text3, pattern3);
// Ожидаемый результат: []

// Пример 4 (Краевой случай)
String text4 = "a";
String pattern4 = "a";
List<Integer> result4 = findAllOccurrences(text4, pattern4);
// Ожидаемый результат: [0]

// Пример 5 (Краевой случай)
String text5 = "abc";
String pattern5 = "";
List<Integer> result5 = findAllOccurrences(text5, pattern5);
// Ожидаемый результат: []

# Theory

Теория: Поиск подстроки с помощью префикс-функции

## Префикс-функция

**Определение:** Для строки `s` длины `n` префикс-функция `π[i]` — это длина наибольшего собственного суффикса подстроки `s[0..i]`, который одновременно является её префиксом.

**Формально:**
```
π[i] = max{k | 0 ≤ k ≤ i, s[0..k-1] = s[i-k+1..i]}
```

**Свойства:**
- `0 ≤ π[i] < i+1` (собственный суффикс)
- `π[0] = 0` (для строки длины 1 нет собственных суффиксов)

## Алгоритм вычисления префикс-функции

**Сложность:** `O(m)`, где `m` — длина строки

**Псевдокод:**
```
function computePrefixFunction(s):
    n = s.length
    π = new Array[n]
    π[0] = 0
    
    for i = 1 to n-1:
        k = π[i-1]
        while k > 0 and s[i] ≠ s[k]:
            k = π[k-1]
        if s[i] == s[k]:
            k += 1
        π[i] = k
    
    return π
```

## Алгоритм Кнута-Морриса-Пратта (KMP)

**Идея:** Использование префикс-функции для эффективного поиска подстроки без возвратов в тексте.

**Сложность:** `O(n + m)`, где:
- `n` — длина текста
- `m` — длина образца

**Псевдокод поиска:**
```
function KMP(text, pattern):
    if pattern.empty() or pattern.length > text.length:
        return empty list
    
    π = computePrefixFunction(pattern)
    result = []
    k = 0
    
    for i = 0 to text.length-1:
        while k > 0 and text[i] ≠ pattern[k]:
            k = π[k-1]
        if text[i] == pattern[k]:
            k += 1
        if k == pattern.length:
            result.add(i - pattern.length + 1)
            k = π[k-1]
    
    return result
```

## Ключевые преимущества

1. **Эффективность:** Линейная сложность `O(n + m)`
2. **Отсутствие возвратов:** Текст читается последовательно один раз
3. **Предобработка:** Вычисление префикс-функции выполняется один раза для образца

## Пример

Для `pattern = "ababa"`:
```
i: 0 1 2 3 4
s: a b a b a
π: 0 0 1 2 3
```

Объяснение:
- `π[2] = 1`, т.к. `"a"` — наибольший собственный суффикс, являющийся префиксом для `"aba"`
- `π[4] = 3`, т.к. `"aba"` — наибольший собственный суффикс, являющийся префиксом для `"ababa"`

