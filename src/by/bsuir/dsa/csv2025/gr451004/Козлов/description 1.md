# Название

Реализация структуры данных CustomBitSet

# Описание

Реализация структуры данных CustomBitSet

Реализуйте структуру данных `CustomBitSet` на языке Java, которая представляет собой динамический набор битов с возможностью эффективного выполнения операций над множествами.

## Требования к реализации

### Базовый функционал:

- **Конструкторы**:
    - Конструктор по умолчанию, создающий bitset стандартного размера
    - Конструктор с указанием начального количества битов

### Основные операции:

- `set(int bitIndex)` - установить бит в позиции bitIndex
- `set(int bitIndex, boolean value)` - установить бит в указанное значение
- `clear(int bitIndex)` - очистить бит
- `clear()` - очистить все биты
- `get(int bitIndex)` - получить значение бита
- `flip(int bitIndex)` - инвертировать бит

### Побитовые операции:

- `and(CustomBitSet other)` - логическое И
- `or(CustomBitSet other)` - логическое ИЛИ
- `xor(CustomBitSet other)` - исключающее ИЛИ
- `andNot(CustomBitSet other)` - разность множеств

### Утилитарные методы:

- `cardinality()` - количество установленных битов
- `isEmpty()` - проверка на пустоту
- `size()` - общий размер в битах
- `length()` - логическая длина (индекс последнего установленного бита + 1)
- `intersects(CustomBitSet other)` - проверка пересечения
- `copy()` - создание копии
- `equals(Object obj)` - сравнение с другим объектом
- `toString()` - строковое представление

### Технические требования:

- Использовать массив `long` для хранения битов (по 64 бита на элемент)
- Реализовать динамическое расширение при необходимости
- Обеспечить обработку граничных случаев и исключительных ситуаций
- Оптимизировать производительность операций

# Краткая теория

Битовые множества (BitSet) — одна из фундаментальных структур данных в компьютерных науках, позволяющая эффективно работать с наборами битов и выполнять логические операции над ними. Однако стандартная реализация может не всегда подходить для специфических задач, что требует создания кастомных решений.

## Архитектура битового множества

Основная идея `CustomBitSet` — хранение битов в массиве 64-битных слов (`long[]`), где каждый элемент массива содержит 64 последовательных бита. Это позволяет эффективно использовать аппаратные возможности современных процессоров для побитовых операций.

### Вычисление индексов

Для доступа к конкретному биту используются битовые операции:

```java
private static int wordIndex(int bitIndex) {
    return bitIndex >> ADDRESS_BITS_PER_WORD; // ADDRESS_BITS_PER_WORD = 6
}
```

Поскольку $2^6 = 64$, операция сдвига вправо на 6 эквивалентна целочисленному делению на 64.

### Маскирование битов

Для работы с отдельными битами внутри слова используется маскирование:

```java
// Установка бита
words[wordIndex] |= (1L << bitIndex);
// Сброс бита  
words[wordIndex] &= ~(1L << bitIndex);
// Проверка бита
(words[wordIndex] & (1L << bitIndex)) != 0
```

## Стратегии управления памятью

### Динамическое расширение

При операциях с битами за пределами текущего размера возникает необходимость расширения. В реализации используются две стратегии:

- **Автоматическое расширение** (`sizeIsSticky = false`) — массив удваивается при необходимости
- **Фиксированный размер** (`sizeIsSticky = true`) — размер сохраняется неизменным

### Оптимизация производительности

Использование `long[]` вместо `int[]` или `byte[]` дает значительный прирост благодаря:

- **Выравниванию памяти** — 64-битные операции эффективнее на современных процессорах
- **Кэш-локальности** — последовательный доступ к соседним битам в одном слове
- **Векторизации** — возможность использования SIMD-инструкций

## Оптимизации для специфических случаев

### Подсчет установленных битов

Метод `cardinality()` использует встроенную функцию `Long.bitCount()`, которая компилируется в специализированную процессорную инструкцию на большинстве современных архитектур:

java

public int cardinality() {
    int count = 0;
    for (long word : words) {
        count += Long.bitCount(word);  // Может использовать инструкцию POPCNT
    }
    return count;
}

### Поиск логической длины

Метод `length()` ищет последний установленный бит, используя эффективные операции:

```java
public int length() {
    // Находим последнее ненулевое слово
    int lastNonZeroWord = words.length - 1;
    while (lastNonZeroWord >= 0 && words[lastNonZeroWord] == 0) {
        lastNonZeroWord--;
    }
    
    if (lastNonZeroWord < 0) return 0;
    
    long lastWord = words[lastNonZeroWord];
    return (lastNonZeroWord + 1) * BITS_PER_WORD - Long.numberOfLeadingZeros(lastWord);
}

```
## Практические рекомендации

### Выбор начального размера

_Практическое правило_: если вам нужно хранить $n$ битов, инициализируйте `CustomBitSet` с запасом в $1.5 \cdot n$ битов для избежания частых расширений.

### Производительность операций

- **Установка/сброс бита**: $O(1)$ амортизированное время
- **Побитовые операции**: $O(\lceil n/64 \rceil)$
- **Подсчет битов**: $O(\lceil n/64 \rceil)$, но с высокой константой

### Потребление памяти

Каждый экземпляр `CustomBitSet` потребляет:

- Заголовок объекта: 16 байт
- Поле `words`: 4-8 байт
- Поле `sizeInBits`: 4 байта
- Поле `sizeIsSticky`: 1 байт
- Выравнивание: ~3 байта
- Массив `long[]`: $8 \cdot \lceil n/64 \rceil$ байт

**Итого**: примерно $24 + 8 \cdot \lceil n/64 \rceil$ байт.

## Математическая модель битовых операций

Рассмотрим битовое множество как вектор битов $B = (b_0, b_1, \ldots, b_{n-1})$, где $b_i \in {0, 1}$.

### Алгебраические свойства

Битовые операции образуют булеву алгебру:

- **Коммутативность**: $A \land B = B \land A$, $A \lor B = B \lor A$
- **Ассоциативность**: $(A \land B) \land C = A \land (B \land C)$
- **Дистрибутивность**: $A \land (B \lor C) = (A \land B) \lor (A \land C)$
- **Законы Де Моргана**: $\neg(A \land B) = \neg A \lor \neg B$


### Вероятностный анализ

Для случайного битового множества размера $n$, где каждый бит устанавливается независимо с вероятностью $p$:

- **Математическое ожидание количества установленных битов**: $E[|B|] = n \cdot p$
    
- **Вероятность того, что два множества пересекаются**:
    

P(A∩B≠∅)=1−(1−pApB)nP(A∩B=∅)=1−(1−pA​pB​)n

где $p_A$ и $p_B$ — вероятности установки бита в множествах $A$ и $B$ соответственно.

