# Название

Изменение цен на акции 

# Описание

Изменение цен на акции 

## Условие задачи

Имеется массив из `n` акций с начальными ценами: `price[0..n-1]`. В течение `m` дней происходят изменения цен.  Каждое изменение - это пара `(индекс_акции, новая_цена)`, означающая, что цена указанной акции в соответствующий день (его порядковый номер равен увеличенному на один индексу в переданном массиве) была изменена на новое значение.

Начальник посылает аналитику запросы вида `(start, end, k)`, где:

- `start`, `end` - индексы акций (диапазон `[start, end]`)
- `k` - количество учитываемых изменений (первые `k` штук)

Нужно рассмотреть состояние цен на конец дня `end`, но для акций в диапазоне `[start, end]` учесть только первые `k` изменений, которые:

   - Затронули акции на отрезке `[start, end]`
   - Произошли в период со дня `start` по день `end`

Необходимо найти **медианную цену** (то есть при нечетной длине массива - центральный элемент, при четной - среднее арифметическое двух центральных) акций с индексами от `start` до `end`.

# Краткая теория

---
title: Изменение цен на акции 
weight: 2
authors:
- Линник Мария
created: 2025
---
# Проблема запросов

## Проблематика

Иногда требуется отвечать на запросы вида:  
**"Как выглядели данные в момент времени T?"**. Наивное решение - хранить полные копии данных для каждого изменения - требует **O(m·n)** памяти, что неприемлемо при больших значениях `m` и `n`.

## Ключевое наблюдение

При последовательных изменениях данных каждое следующее состояние отличается от предыдущего только в **одном элементе**. Это позволяет строить **персистентные структуры данных**.

### Преимущество персистентных структур

- Хранят все версии, используя память **O(n + m log n)** вместо **O(m·n)**

# Персистентное дерево отрезков

Для решения задачи подходит персистентное дерево отрезков, поддерживающее:

- **Обновление одного элемента** за `O(log n)`
- **Запрос суммы на отрезке** за `O(log n)`
- **Хранение всех версий** с суммарной памятью `O((n + m) log n)`

### Реализация на C++

```cpp
struct Node {
    int sum;
    Node *left, *right;
    Node(int s, Node* l, Node* r) : sum(s), left(l), right(r) {}
};

vector<Node*> versions; // Корни всех версий
```
##k-ая порядковая статистика

Для нахождения медианы на отрезке в персистентном дереве отрезков используется техника k-й порядковой статистики:

    1. Сжимаем координаты цен.
    2. Строим персистентное дерево отрезков, где в `i-й` версии учтены первые `i` изменений.
    3. Для запроса `(start, end, k)` находим, какая версия соответствует первым `k` изменениям на отрезке.
    4. Используем бинарный поиск для нахождения медианы.

