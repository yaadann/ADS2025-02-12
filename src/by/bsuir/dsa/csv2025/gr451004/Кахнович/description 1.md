# Название

Минимальный путь по подмножествам

# Описание

Минимальный путь по подмножествам

Даны `n` городов и матрица расстояний `dist` размером `n × n`, где `dist[i][j]` — расстояние от города `i` до города `j`. 

Найдите минимальную длину пути, который начинается в городе `0`, посещает **ровно `k` различных городов** (включая стартовый), и возвращается в город `0`.

## Входные данные

- Первая строка: `n k` (`2 ≤ k ≤ n ≤ 18`)
- Следующие `n` строк: матрица `n × n`, где `dist[i][j]` — целое число (`0 ≤ dist[i][j] ≤ 10^6`)
- Гарантируется, что `dist[i][j] = dist[j][i]` и `dist[i][i] = 0`

## Выходные данные

- Одно число — минимальная длина пути. Если невозможно посетить ровно `k` городов и вернуться в 0, выведите `-1`.

## Пример


# Краткая теория

title: Динамическое программирование по подмножествам
weight: 3
authors:
- Кахнович Влад
created: 2025
---

Задача является вариацией знаменитой **задачи коммивояжёра (TSP)** — одной из самых изученных NP-трудных задач в комбинаторной оптимизации. В отличие от классической TSP, где нужно посетить все города, здесь требуется посетить ровно `k` городов, что делает задачу более гибкой для практического применения.

## Метод решения

Используем **динамическое программирование по подмножествам** с состоянием:

`dp[mask][i]` — минимальная длина пути, который:
- Посетил города из битовой маски `mask` (где `mask & (1 << j)` означает, что город `j` посещён)
- Закончил в городе `i`

**Алгоритм:**
1. Инициализируем `dp[1][0] = 0` (начинаем в городе 0)
2. Перебираем все маски в порядке возрастания количества битов
3. Для каждой маски и последнего города обновляем состояния для всех непосещённых городов
4. В конце среди всех масок с ровно `k` битами (включая город 0) находим минимальный путь с возвратом в 0

## Сложность и оптимизации

**Временная сложность:** *O(n²·2ⁿ)*  
**Память:** *O(n·2ⁿ)*

При `n ≤ 18` общее число операций составляет примерно:
- 18² = 324
- 2¹⁸ = 262,144  
- Итого: ~85 миллионов операций, что выполнимо за несколько секунд.

**Оптимизации:**
- Предвычисление масок с нужным количеством битов
- Использование симметрии расстояний
- Раннее отсечение невозможных состояний

## Практическое применение

Подобные задачи возникают в:
- **Логистике** — планирование маршрутов доставки с ограничением по времени/точкам
- **Туризме** — построение оптимальных экскурсионных маршрутов
- **Сетевом проектировании** — оптимизация подключения узлов сети

## Дальнейшее развитие

Для больших `n` (до 25-30) можно использовать:
- **Meet-in-the-middle** подход
- **Эвристические алгоритмы** (муравьиные колонии, генетические алгоритмы)
- **Приближённые алгоритмы** с гарантированной точностью

