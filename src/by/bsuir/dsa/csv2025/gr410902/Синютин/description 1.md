# Название

Проектирование динамического массива с запросами суммы

# Описание

Дизайн структуры данных Dynamic Range Sum Array

Вам необходимо разработать структуру данных `DynamicStream`, которая имитирует поведение динамического массива, но оптимизирована для частых операций вставки, удаления и запросов суммы на диапазоне. Стандартный `ArrayList` в Java выполняет вставку и удаление за $O(N)$ времени, что слишком медленно для больших объемов данных при смешанных операциях.

# Краткая теория

title: Sqrt-декомпозиция и Unrolled Lists

weight: 2

authors:

- Синютин Назар

  created: 2025

------

У стандартных динамических массивов (вроде `ArrayList` в Java или `std::vector` в C++), есть один неприятный недостаток: линейная сложность сдвига. Если мы будем просто вставлять элементы в начало массива, то каждый раз нам придется сдвигать всё содержимое вправо. На LeetCode и CodeForces часто встречаются задачи, где наивное решение ловит **Time Limit Exceeded (TLE)** — можно специально сгенерировать тест, состоящий из одних вставок в начало (`index = 0`). Есть даже [гайды](https://en.wikipedia.org/wiki/Unrolled_linked_list) про то, как обходить это ограничение, разбивая данные на части.

Событие, когда один блок переполняется и требует разделения, называется *сплитом* (split). Пусть мы решаем задачу поддержки массива с вставками — мы храним элементы в виде связного списка небольших массивов (блоков). Понятно, что если выбрать размер блока неправильно, то мы либо получим слишком длинный список блоков, либо слишком тяжелые операции внутри блока, и получим TLE. Насколько большим следует делать размер блока $B$, чтобы не бояться такого?



## Выбор констант



*Практическое правило:* если вам нужно хранить $N$ элементов, то оптимальный размер блока — это число порядка $\sqrt{N}$. Обоснование — см. раздел про оптимизацию баланса.

Не всегда этот размер можно выбрать статически — если количество элементов $N$ сильно меняется (от 0 до $10^5$), фиксированная константа может быть неэффективной. Вместо этого можно делать динамическую балансировку (слияние и разделение блоков).

Можно также брать фиксированный «размер» порядка 300-500 (для $N=10^5$). У этого есть несколько преимуществ:

- Это просто — не нужно пересчитывать корень на каждом шаге.
- С таким размером мы попадаем в кэш процессора (L1/L2 cache) — итерирование по маленькому массиву (`ArrayList`) внутри блока происходит экстремально быстро.
- С ним аллокация памяти реже — Java/C++ не любят создавать миллион объектов по 1 элементу, лучше создать тысячу объектов по 100 элементов.

Всё с этим подходом было прекрасно, пока не придумали тесты на «пилообразную» нагрузку (много вставок и удалений на границе блока). Однако их добавляют далеко не на все задачи — имейте это в виду.

В выборе же конкретного $B$ (Block Size) ограничения не такие жесткие:

- Она должна быть не меньше $\sqrt{N}$ — иначе список блоков станет слишком длинным, и поиск нужного блока займет $O(N)$.
- Она не должна быть слишком большой — иначе вставка внутри блока (сдвиг хвоста) снова станет линейной.

Главное — чтобы ваше решение не деградировало в обычный `LinkedList` (где блок = 1 элемент) или обычный `ArrayList` (где блок = $N$ элементов).



## Оптимизация баланса



> Чтобы минимизировать время выполнения операций вставки и поиска в структуре из блоков, размер каждого блока должен стремиться к квадратному корню из общего числа элементов.

Более общее утверждение: для структуры размера $N$ сумма затрат на поиск блока и работу внутри блока минимальна при размере блока $\Theta(\sqrt{N})$.

Первое доказательство (для любителей матана). Пусть $T(N, B)$ это время операции, где $N$ — общее число элементов, а $B$ — размер одного блока.

Будем считать, что в среднем нам нужно пройти половину списка блоков, чтобы найти нужный, и сдвинуть половину элементов внутри блока.

Количество блоков равно $N / B$.

$$T(N, B) \approx C_1 \cdot \frac{N}{B} + C_2 \cdot B$$

Попытаемся найти минимум функции $T$ по переменной $B$. Возьмем производную по $B$ и приравняем к нулю:

$$\begin{aligned}    T'(B) & = -\frac{C_1 \cdot N}{B^2} + C_2 \\    0 & = -\frac{C_1 \cdot N}{B^2} + C_2 \\    \frac{C_1 \cdot N}{B^2} & = C_2 \\    B^2 & = \frac{C_1}{C_2} \cdot N \\    B & \approx \sqrt{N} \cdot \sqrt{\frac{C_1}{C_2}} \\ \end{aligned}$$

Из последнего выражения более-менее понятно, что оптимум достигается при $B \approx \sqrt{N}$ (с поправкой на константы операций). Если $C_1 \approx C_2$, то $B = \sqrt{N}$.

**Второе доказательство** (через неравенство о средних). Введем две величины: "цена навигации" $X = \frac{N}{B}$ и "цена сдвига" $Y = B$. Мы хотим минимизировать их сумму $X + Y$.

Известно, что произведение $X \cdot Y = \frac{N}{B} \cdot B = N$ является константой.

Согласно неравенству Коши (о средних арифметическом и геометрическом), сумма двух положительных чисел с фиксированным произведением минимальна тогда, когда эти числа равны.

$$\frac{X + Y}{2} \ge \sqrt{XY} \implies X + Y \ge 2\sqrt{N}$$

Равенство (минимум суммы) достигается, когда $X = Y$, то есть $\frac{N}{B} = B$, откуда $B^2 = N \Rightarrow B = \sqrt{N}$.

*Примечание*: формально, на практике $C_1$ (проход по списку ссылок) дороже, чем $C_2$ (проход по массиву в кэше), поэтому блоки часто делают чуть больше, чем чистый $\sqrt{N}$.



### Бонус: «мета-задача»



Вам дан скомпилированный класс `BlackBoxList`, реализующий этот алгоритм. Вы не видите код, но знаете, что внутри используется Sqrt-декомпозиция с фиксированным размером блока $B$. В задаче ограничение по времени 2 секунды. У вас есть возможность вызывать методы `insert` и `get`.

«Взломайте» структуру: напишите код, который экспериментальным путем (замеряя время выполнения операций) определит скрытую константу $B$ с точностью до 10%, используя не более $2 \cdot 10^5$ операций.

