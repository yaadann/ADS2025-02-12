# Название

Слияние k отсортированных массивов

# Описание

Слияние k отсортированных массивов
## Темы: Двоичная куча (Min-Heap), Приоритетная очередь

---

## Описание задачи

Даны `k` отсортированных по неубыванию массивов целых чисел. Требуется объединить их в один общий отсортированный массив.

---

## Формат ввода

В первой строке содержатся два целых числа:

```
k n
```

где
`k` — количество отсортированных массивов,
`n` — максимальная возможная длина одного массива.

Далее следуют `k` строк. Каждая строка описывает один массив в формате:

```
len_i a1 a2 ... a_len_i
```

где
`len_i` — реальная длина массива,
`a_j` — элементы массива, отсортированные по неубыванию.

Гарантируется, что:

```
M = sum(len_i) ≤ 10^6
```

---

## Формат вывода

Выведите все элементы всех массивов, объединённые в один отсортированный массив, в одну строку через пробел.

---

## Требования по эффективности

Не допускается объединение всех элементов в один массив и сортировка его стандартной сортировкой (`O(M log M)`).

Ожидаемое решение должно работать за:

```
O(M log k)
```

Рекомендуется использование минимальной двоичной кучи (min-heap).

---

## Пример

### Ввод:

```
3 5
3 1 4 9
2 2 7
4 0 5 6 10
```

### Вывод:

```
0 1 2 4 5 6 7 9 10
```

# Краткая теория


---
title: Двоичная куча
weight: 2
authors:
- Горьковой Никита
created: 2025
---

Двоичная куча используется во многих алгоритмах, где требуется многократно выбирать минимальный элемент из динамически изменяемого набора данных. Линейные структуры предоставляют такую операцию за `O(n)`, что при больших объёмах данных приводит к потере эффективности. В задачах, где требуется обработать сотни тысяч операций вставки и извлечения, такая асимптотика неприемлема. Стандартным решением является использование двоичной кучи, обеспечивающей `O(log n)` время всех основных операций.

Двоичная куча представляет собой почти полное бинарное дерево, удовлетворяющее инварианту: значение в каждой вершине не больше значений в её дочерних вершинах. При этом структура хранится в обычном массиве. Пусть корень имеет индекс `1`. Тогда его дети находятся по индексам `2` и `3`, их дети — по `4, 5, 6, 7` и так далее. Такой способ представления исключает необходимость использования указателей и динамического выделения памяти.

Главные операции — вставка и извлечение минимума — основаны на локальных перестановках элементов (sift-up и sift-down). При вставке новый элемент помещается в конец массива и поднимается вверх, пока не будет восстановлено свойство кучи. При извлечении минимума последний элемент перемещается в корень и опускается вниз. В обоих случаях глубина дерева равна `O(log n)`, поэтому общее время операции также `O(log n)`.

Рассмотрим задачу слияния `k` отсортированных массивов. Если просто объединить все элементы и отсортировать, то получим сложность `O(M log M)`, где `M` — общее число элементов. Однако структура задачи позволяет сделать лучше. На каждом шаге минимальным среди всех оставшихся элементов может быть только первый элемент какого-либо массива. Кандидатов всего `k`. Поиск минимума за `O(k)` даёт итог `O(Mk)`, что слишком медленно. Если же хранить эти кандидаты в двоичной куче, то каждая операция выбора минимума будет занимать `O(log k)`, и полная сложность составит:

```
O(M log k)
```

Это оптимально: нельзя находить минимум среди `k` элементов быстрее, чем за логарифмическое время в сравнивающих структурах.

Куча не обеспечивает полной упорядоченности элементов — только необходимый минимум структуры. Она не является отсортированным массивом, и порядок между элементами, не находящимися на одном пути от корня, не определён. Это сознательная компромиссная конструкция: минимально необходимый порядок даёт минимальную сложность.

В отличие от хеширования, куча работает полностью детерминированно. Здесь нет случайности, коллизий, зависимостей от подсчёта остатков или особенностей процессора. Все операции выполняются в строго определённом порядке и дают гарантированную асимптотику.

## Выбор реализации

На практике куча почти всегда реализуется в массиве. 1-индексация позволяет удобно вычислять индексы детей и родителей, но многие библиотеки используют 0-индексацию — это не влияет на асимптотику.

Кучу можно использовать не только для хранения обычных чисел, но и более сложных структур, например, тройки вида (значение, номер массива, индекс внутри массива). Сравнение по ключу остаётся константным, поэтому операция остаётся `O(log n)`.

## Асимптотика

Последовательность операций вставки и извлечения минимума имеет амортизированную сложность `O(log n)`. В задачах типа слияния массивов итоговая асимптотика равна:

```
O(M log k)
```

где `M` — суммарное число элементов.

Эта оценка является оптимальной среди всех сравнивающих структур данных.

