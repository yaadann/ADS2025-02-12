# Название

Поиск маршрутов общественного транспорта

# Описание

Поиск маршрутов общественного транспорта
В городе был построен новый микрорайон со своей отдельной остановкой под общественный транспорт, необходимо определить по каким станциям должен проехать новый автобус или троллейбус, чтобы добраться наиболее быстро до нового микрорайона.
## Формат входных данных
- В первой строке через пробел вводятся четыре числа:  
1. Количество остановок `n`,  
2. Количество дорог между остановками `m`.  
3. Номер начальной остановки маршрута
4. Номер конечной остановки маршрута
- Следующие n строк необходимо проставить соответствие между номерами станции и их номером. Сначала идёт название станции (если два слова, то через нижнее подчёркивание) и после номер который ей соответствует 
- В каждой из следующих строк необходимо указать все существующие пути между остановками; через пробел вводятся три значения:  
1. Номер первой остановки,  
2. Номер второй остановки,  
3. Расстояние между ними.
---
## Формат выходных данных
- В первой строке должны быть указаны названия всех остановок, через которые проходит кратчайший путь (формат такой: Остановка -> Остановка -> ...)  
- Во второй строке необходимо вывести суммарное расстояние, которое проходит общественный транспорт.
---
## Дополнительные условия
- Реализация должна применять алгоритм Дейкстры, причём для плотных и разреженных графов необходимо применять оптимальные конкретно для них алгоритмы.
- Так как общественный транспорт ходит всегда в обе стороны, то графы мы рассматриваем как неориентированные

# Краткая теория

Алгоритм Дейкстры
Алгоритм Дейкстры находит кратчайшие пути от заданной вершины $s$ до всех остальных в графе без ребер отрицательного веса.
Существует два основных варианта алгоритма, время работы которых составляет $O(n^2)$ и $O(m \log n)$, где $n$ — число вершин, а $m$ — число ребер.
## Основная идея
Заведём массив $d$, в котором для каждой вершины $v$ будем хранить текущую длину $d_v$ кратчайшего пути из $s$ в $v$. Изначально $d_s = 0$, а для всех остальных вершин расстояние равно бесконечности (или любому числу, которое заведомо больше максимально возможного расстояния).
Во время работы алгоритма мы будем постепенно обновлять этот массив, находя более оптимальные пути к вершинам и уменьшая расстояние до них. Когда мы узнаем, что найденный путь до какой-то вершины $v$ оптимальный, мы будем помечать эту вершину, поставив единицу ($a_v=1$) в специальном массиве $a$, изначально заполненном нулями.
Сам алгоритм состоит из $n$ итераций, на каждой из которых выбирается вершина $v$ с наименьшей величиной $d_v$ среди ещё не помеченных:
$$
v = \argmin_{u | a_u=0} d_u 
$$
Выбранная вершина отмечается в массиве $a$, после чего из из вершины $v$ производятся *релаксации*: просматриваем все исходящие рёбра $(v,u)$ и для каждой такой вершины $u$ пытаемся улучшить значение $d_u$, выполнив присвоение
$$
d_u = \min (d_u, d_v + w)
$$
где $w$ — длина ребра $(v, u)$.
На этом текущая итерация заканчивается, и алгоритм переходит к следующей: снова выбирается вершина с наименьшей величиной $d$, из неё производятся релаксации, и так далее. После $n$ итераций, все вершины графа станут помеченными, и алгоритм завершает свою работу.
### Для плотных графов
Если $m \approx n^2$, то на каждой итерации можно просто пройтись по всему массиву и найти $\argmin d_v$.
Асимптотика такого алгоритма составит $O(n^2)$: на каждой итерации мы находим аргминимум за $O(n)$ и проводим $O(n)$ релаксаций.
### Для разреженных графов
Если $m \approx n$, то минимум можно искать быстрее. Вместо линейного прохода заведем структуру, в которую можно добавлять элементы и искать минимум — например `std::set` так умеет.
Будем поддерживать в этой структуре пары $(d_v, v)$, при релаксации удаляя старый $(d_u, u)$ и добавляя новый $(d_v + w, u)$, а при нахождении оптимального $v$ просто беря минимум (первый элемент).
Поддерживать массив $a$ нам теперь не нужно: сама структура для нахождения минимума будет играть роль множества ещё не рассмотренных вершин.
Для каждого ребра нужно сделать два запроса в двоичное дерево, хранящее $O(n)$ элементов, за $O(\log n)$ каждый, поэтому асимптотика такого алгоритма составит $O(m \log n)$. Заметим, что в случае полных графов это будет равно $O(n^2 \log n)$, так что про предыдущий алгоритм забывать не стоит.
### Восстановление путей
Часто нужно знать не только длины кратчайших путей, но и получить сами пути.
Для этого можно создать массив $p$, в котором в ячейке $p_v$ будет хранится *родитель* вершины $v$ — вершина, из которой произошла последняя релаксация по ребру $(p_v, v)$. Обновлять его можно параллельно с массивом $d$. 
Для восстановления пути нужно просто пройтись по предкам вершины $v$:

