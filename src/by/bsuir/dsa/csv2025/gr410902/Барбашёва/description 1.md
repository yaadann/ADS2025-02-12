# Название

Проверка корректности расписания курсов

# Описание

Проверка корректности расписания курсов



**Условие**

В университете есть список курсов, которые должны быть пройдены студентами. Некоторые курсы имеют предварительные требования. Например, чтобы записаться на курс "Алгоритмы", нужно сначала пройти курс "Структуры данных".



Дан список курсов и их куров предшественников. Определите, возможно ли закончить все курсы, не попадая в ситуацию "циклической зависимости" (когда курс A требует курс B, а курс B требует курс A).



**Формат входных данных**

Первое число: количество курсов n

Второе число: количество зависимостей m

Далее m пар чисел: пары a b, где курс b является предварительным требованием для курса a



**Формат выходных данных**

true - если можно закончить все курсы (нет циклических зависимостей)

false - если есть циклические зависимости



**Пример**

Вход:

4 3 1 0 2 1 3 2

Выход:

true


# Краткая теория

Теория: Обход графов и обнаружение циклов

## Основные понятия

### Графы
**Граф** - структура данных, состоящая из:
- **Вершин** (узлов) - основных элементов
- **Рёбер** - связей между вершинами

**Ориентированный граф** - граф, где рёбра имеют направление (A → B означает, что можно перейти из A в B, но не обязательно обратно).

### Представление графов
**Список смежности** - способ представления графа, где для каждой вершины хранится список смежных с ней вершин:
0: [1, 2]
1: [3]
2: [1]
3: []

## Алгоритмы обхода графов

### Поиск в глубину (DFS)
**Идея**: Идём "вглубь" по одному пути, пока это возможно, затем возвращаемся.

**Компоненты**:
- **visited** - отметки о посещённых вершинах
- **Рекурсивный обход** смежных вершин

### Обнаружение циклов в ориентированном графе

**Ключевая идея**: Цикл существует, если при обходе мы встречаем вершину, которая находится в текущем пути обхода.

**Используемые массивы**:
- `visited[]` - вершины, которые уже полностью обработаны
- `stack[]` (или `inPath[]`) - вершины, находящиеся в текущем пути рекурсии

**Алгоритм**:
1. Пометить вершину как посещённую и добавить в текущий путь
2. Для каждой смежной вершины:
   - Если она уже в текущем пути → обнаружен цикл
   - Если не посещена → рекурсивно обойти
3. Убрать вершину из текущего пути перед возвратом

## Сложность алгоритма
- **Время**: O(V + E), где V - количество вершин, E - количество рёбер
- **Память**: O(V) для массивов посещений и стека

