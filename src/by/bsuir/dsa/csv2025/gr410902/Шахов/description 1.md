# Название

Система управления задачами

# Описание

Система управления задачами

## ЗАДАНИЕ
* Реализуйте систему управления задачами.
* Каждая задача состоит из имени и приоритета (целое число).
## Необходимо:

1) Реализовать собственный динамический массив (без использования ArrayList). 
2) Реализовать итератор по динамическому массиву.
3) Реализовать двоичную max-кучу для получения задачи с максимальным приоритетом.  
4) Реализовать метод getNextTask(), возвращающий задачу с максимальным приоритетом в виде кортежа (ключ–значение): (имя, приоритет).  
5) Все задачи должны сохраняться как в динамическом массиве, так и в куче.  

Использовать ООП-структуру.

# Краткая теория

Базовые структуры данных  
## Массивы, кортежи, итераторы, динамический массив и двоичная куча

---

## 1. Массивы

**Массив** — упорядоченная последовательность элементов одинакового типа, хранящихся в *непрерывной области памяти*.  
Доступ по индексу выполняется за:

```
O(1)
```

### Свойства
- фиксированный размер  
- быстрый доступ по индексу  
- дешевое хранение  
- дорогие вставки и удаления в середине  

### Операции
| Операция | Время |
|----------|--------|
| Чтение `a[i]` | `O(1)` |
| Запись `a[i] = x` | `O(1)` |
| Вставка в середину | `O(n)` |
| Удаление из середины | `O(n)` |

---

## 2. Кортежи

**Кортеж (tuple)** — неизменяемая структура фиксированной длины, содержащая несколько значений.

Используется для:
- возврата двух и более значений из функции  
- хранения небольшой логической группы данных  

Пример:
```java
return new AbstractMap.SimpleEntry<>("task", 5);
```

---

## 3. Итераторы

Итератор — объект, позволяющий последовательно обходить элементы структуры данных без знания ее внутреннего устройства.

Минимальный интерфейс:

```java
boolean hasNext();
T next();
```

### Зачем нужны итераторы?
- абстракция структуры: массив, список, дерево — неважно  
- позволяют использовать `for-each`  
- делают обход ленивым (выдача элементов по одному)

---

## 4. Динамический массив

Динамический массив автоматически расширяется при заполнении.

### Как работает расширение
1. Создаётся новый массив, обычно в 2 раза больше.  
2. Старые данные копируются.  
3. Ссылка заменяется.

### Сложность
Добавление в конец амортизированно:

```
O(1)
```

### Свойства
- быстрый индексный доступ  
- автоматический рост  
- дешёвое добавление в конец  
- дорогие вставки/удаления в середине

---

## 5. Двоичная куча (Binary Heap)

**Куча** — полное бинарное дерево, удовлетворяющее свойству:

- **max-heap**: родитель ≥ потомков  
- **min-heap**: родитель ≤ потомков  

### Представление в массиве
Используется обычный массив.

Формулы индексов:

```
parent(i) = (i - 1) / 2
left(i)   = 2*i + 1
right(i)  = 2*i + 2
```

### Операции

| Операция | Описание | Время |
|----------|----------|--------|
| `add(x)` | вставка + sift-up | `O(log n)` |
| `extractMax()` | удаление корня + sift-down | `O(log n)` |
| просмотр корня | возврат `heap[0]` | `O(1)` |

### Где используется?
- очередь с приоритетами  
- сортировка HeapSort  
- алгоритмы на графах (Дейкстра, Прим)

---

## 6. Объединение структур в задачах

Комбинация динамического массива + итератора + кучи позволяет:

- хранить задачи в массиве, расширяемом по необходимости  
- перебирать их через итератор  
- получать задачу с максимальным приоритетом через кучу  

Это классический механизм реализации **priority queue** и систем планировщиков.

---


