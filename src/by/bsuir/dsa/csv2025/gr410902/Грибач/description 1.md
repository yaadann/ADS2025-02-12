# Название

Mo алгоритм с обновлениями и подсчёт различных чисел

# Описание


Дан массив целых чисел `a` длины `n`.  
Также задано `q` операций двух типов:

### Тип 1 — запрос

1 l r

Нужно определить **количество различных чисел** на отрезке `[l, r]` массива **с учётом всех обновлений**, выполненных до этого запроса.

### Тип 2 — обновление

2 pos val

Изменить значение элемента массива в позиции `pos` на `val`.

> Обновления влияют только на запросы, которые идут после них во входных данных.

---

## Требуется

Обработать все запросы **офлайн** с помощью алгоритма **Mo’s algorithm with updates**:

- Перемещать границы отрезка `L` и `R`.
- Применять и откатывать обновления по "времени" `T`.
- Поддерживать количество различных чисел через функции `add(x)` и `remove(x)`.
- Сжать координаты значений массива и обновлений.
- Отсортировать запросы по тройному ключу:
  1. Блок `l`
  2. Блок `r`
  3. Время `t`

---

## Формат входных данных

n q
a1 a2 ... an
Далее q строк — операции:
1 l r
2 pos val


- `1 ≤ n, q ≤ 200000`
- `ai` и `val` — любые целые числа

---

## Формат выходных данных

Для каждого запроса типа 1 вывести одно число — количество различных элементов на указанном отрезке.  
Порядок вывода должен совпадать с порядком запросов во входных данных.

---

## Пример

### Вход

5 5
1 2 1 3 2
1 1 5
2 3 10
1 2 4
2 5 1
1 1 5


### Выход

3
3
4


# Краткая теория

## **1. Постановка задачи**

Дан массив ( a ) длины ( n ).
Есть два вида операций:

1. **Запросы на отрезке**
   [
   Q(l, r) = \text{количество различных чисел на } [l, r].
   ]

2. **Обновления**
   [
   U(p, x):\quad a_p := x.
   ]

Запросы и обновления перемешаны в одном списке, и нужно вывести ответ для каждого запроса.

Такая постановка называется **Mo's algorithm with modifications**
или **Mo's algorithm with updates**.

---

## **2. Проблема и мотивация**

Классический Mo работает только если массив **не меняется**.

Но здесь между запросами могут быть обновления, и значение элемента на момент запроса зависит от того, **сколько обновлений уже прошло**.

Поэтому стандартный Mo не подходит.

---

## **3. Идея расширения Mo алгоритма**

Мы вводим третье измерение — **время**.

### Каждый запрос теперь имеет параметры:

[
(l, r, t),
]
где:

* (l, r) ― границы отрезка
* (t) ― **сколько обновлений произошло до этого запроса**

---

## **4. Блоки и сортировка**

Мы делим:

* координату (l) на блок размера (B)
* координату (r) на блок размера (B)
* время (t) тоже делим на блоки

Тогда сортировка запросов выглядит так:

1. Сначала по блоку (l)
2. Потом по блоку (r)
3. Потом по времени (t)

Обычно:
[
B = n^{2/3}.
]

Эмпирически это даёт оптимальную асимптотику:
[
O((n + q) \cdot n^{2/3}).
]

---

## **5. Три типа движения**

Во время обработки следующего запроса нужно привести текущее состояние к нужному:

### **1. Движение по L:**

[
\text{add/remove}(a[L])
]

### **2. Движение по R:**

[
\text{add/remove}(a[R])
]

### **3. Движение по времени T:**

Если мы хотим перейти от времени (t) к (t+1) —
мы применяем **следующее обновление**.

Если нужно перейти назад — откатываем обновление:

[
a_{pos} := old_value.
]

Если обновление относится к позиции, которая сейчас внутри ([L, R]),
нужно переобработать элемент:

* убрать старое значение
* добавить новое

---

## **6. Подсчёт количества различных**

Храним массив частот:

[
cnt[x]
]

Когда добавляем элемент:

* если (cnt[x] = 0), увеличиваем ответ
* увеличиваем (cnt[x])

Когда удаляем:

* уменьшаем (cnt[x])
* если (cnt[x] = 0), уменьшаем ответ

Таким образом текущее количество различных элементов в отрезке всегда известно.

---

## **7. Асимптотика**

[
O\left((n + q) \cdot n^{2/3}\right)
]

Память:

[
O(n)
]

Это быстрее, чем квадратные решения, и достаточно быстро для больших входов.

---

* Обновления нужно хранить в отдельном массиве.
* Для каждого запроса нужно запомнить, сколько обновлений было до него.
* Откаты по времени должны корректно обрабатывать ситуацию, когда обновление находится **внутри текущего отрезка**.


