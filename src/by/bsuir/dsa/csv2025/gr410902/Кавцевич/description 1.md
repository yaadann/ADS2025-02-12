# Название

Система мониторинга мегаполиса

# Описание

Система мониторинга мегаполиса

Необходимо использовать корневую декомпозицию (SQRT-DECOMPOSITION).

Город состоит из **N районов**.  
Для каждого района хранится числовой показатель — **загрязнение воздуха**.

Городской центр управления получает **Q запросов** четырёх типов:

- **1 l r** — вывести *суммарное загрязнение* на участке `[l, r]` районов.  
- **2 i x** — *обновить данные*: установить новый уровень загрязнения района `i` равным `x`.  
- **3 l r** — вывести *минимальный уровень загрязнения* на участке `[l, r]`.  
- **4 l r** — вывести *максимальный уровень загрязнения* на участке `[l, r]`.

## Входные данные

- Первая строка содержит два целых числа: `N` и `Q`.
- Вторая строка содержит `N` целых чисел — начальные уровни загрязнения.
- Далее следуют `Q` строк запросов.
- `1 ≤ N, Q ≤ 200000`.

## Выходные данные

Для каждого запроса типа **1, 3 и 4**  
выведите соответствующий результат — **по одному числу на строку**.

## Пример

### Sample Input:
5 4
1 2 3 4 5
1 1 5
3 2 4
4 1 3
2 3 10

### Sample Output:
15
2
3

# Краткая теория

Корневые структуры
---

## Корневая декомпозиция на массивах

Сделаем вид, что про дерево отрезков мы не знаем, и рассмотрим следующую задачу.

**Задача.** Дан массив `a` длины `n`. Требуется отвечать на `q` запросов одного из двух типов:

1. Найти сумму на отрезке `[l, r]`.
2. Увеличить все элементы на отрезке `[l, r]` на `x`.

Разделим весь массив на блоки по `c ≈ sqrt(n)` элементов и посчитаем сумму на каждом блоке. Так как блоки не пересекаются, суммарно это будет работать за `O(n)`.

```cpp
// c это и количество блоков, и также их размер; оно должно быть чуть больше корня
const int maxn = 1e5, c = 330;
int a[maxn], b[c], add[c];

for (int i = 0; i < n; i++)
    b[i / c] += a[i];
```

Заведем также массив `add` размера числа блоков, который будем использовать для отложенной операции прибавления на блоке: будем считать, что реальное значение `i`-го элемента равно `a[i] + add[i / c]`.

Теперь мы можем отвечать на запросы первого типа за `O(n)` операций на запрос:

* Для всех блоков, лежащих целиком внутри запроса, просто возьмём уже посчитанные суммы и сложим.
* Для блоков, пересекающихся с запросом только частично (их максимум два — правый и левый), проитерируемся по нужным элементам и поштучно прибавим к ответу.

Есть много разных стилей, как это реализовать, но автор предпочитает такой:

```cpp
int sum(int l, int r) {
    int res = 0;
    while (l <= r) {
        // если мы находимся в начале блока и он целиком в запросе
        if (l % c == 0 && l + c - 1 <= r) {
            res += b[l / c];
            l += c; // мы можем прыгнуть сразу на блок
        }
        else {
            res += a[l] + add[l / c];
            l += 1;
        }
    }
    return res;
}
```

Обновление пишется примерно так же — для целиком лежащих кусков обновляем `add` и сумму, для остальных отдельные элементы:

```cpp
void upd(int l, int r, int x) {
    while (l <= r) {
        if (l % c == 0 && l + c - 1 <= r) {
            b[l / c] += c * x;
            add[l / c] += x;
            l += c;
        }
        else {
            b[l / c] += x;
            a[l] += x;
            l++;
        }
    }
}
```

Обе операции будут работать за `O(sqrt(n))` в среднем, потому что нужных «центральных» блоков всегда не более `n / c`, а в граничных блоках суммарно не более `2c` элементов.

---

## Внутренние структуры

В блоках корневой декомпозиции можно хранить не только значения каких-то функций для подотрезка, а ещё и самые разные структуры.

Например, хеш-таблица внутри каждого блока позволяет отвечать на запросы вида «число элементов, равных `x` на отрезке», а отсортированным массивом можно решать задачи вида «количество чисел меньших `x` на отрезке» или «сумма на прямоугольнике».

На скорость работы в этих случаях очень сильно влияет размер блока. Ранее мы для простоты использовали одну и ту же константу и для количества блоков, и для их размера, но на практике их часто нужно подбирать.

Для этого нужно смотреть даже не на асимптотику «блочной» и «поштучной» частей, а скорее на относительное реальное время их работы — учитывая, что походы в какое-нибудь декартово дерево совсем не в логарифм раз медленнее линейного, хорошо векторизуемого прохода по массиву. По этой же причине очень часто в корневых эвристиках корень «меньше» логарифма.

---

## Подвижные элементы

**Задача.** Дан массив `a` длины `n`. Требуется отвечать на `q` запросов одного из трёх видов:

1. Вставить элемент `x` на позицию `k` (слева от него окажется ровно `k` элементов).
2. Удалить элемент с позиции `k`.
3. Найти минимум на интервале `[l, r]`.

Здесь предыдущий подход напрямую нельзя применить по той же причине, почему нельзя применить дерево отрезков — вставка и удаление элементов меняют индексы всех правых соседей. Здесь нужно хранить элементы в какой-то более гибкой структуре, не привязанной к статичным индексам.

Разделим все элементы на корневые блоки, и в каждом блоке будем хранить список (`vector` или любой другой подобный контейнер) всех его элементов, а также минимум на этом блоке.

Теперь, когда приходит запрос вставки элемента, мы проходимся по всем блокам, находим нужный блок (такой, что до него идет меньше `k` элементов, а вместе с ним уже больше), и вставляем в него этот элемент, просто перестраивая весь блок с нуля за его размер.

Для удаления делаем почти то же самое — находим нужный блок, находим нужный элемент и удаляем. Для минимума — берем минимум из всех полностью покрытых блоков, и в двух граничных линейным проходом берем минимумы на префиксе или суффиксе.

Отметим, что чтобы находить граничные блоки, мы теперь не можем просто поделить границы на какую-то постоянную — у блоков динамические размеры, и чтобы найти индекс начала какого-то блока, нам нужно просуммировать размеры всех предыдущих блоков.

```cpp
vector< vector<int> > blocks;

// возвращает индекс блока и индекс элемента внутри блока
pair<int, int> find_block(int pos) {
    int idx = 0;
    while (blocks[idx].size() <= pos)
        pos -= blocks[idx++].size();
    return {idx, pos};
}
```

Решение в таком виде будет хорошо работать только первое время, когда каждая операция будет просматривать не более `O(sqrt(n))` блоков и не более `O(sqrt(n))` элементов по отдельности, но с течением времени может получиться, что либо блоков слишком много, либо есть слишком большие блоки. Есть два способа решать эту проблему:

1. После каждой операции добавления или удаления смотреть на затронутый блок, и если его размер больше `2 * B` (где `B` — целевой размер блока), то разделять его на два, а также если он и его сосед в сумме дают меньше `B`, то смерджить их в один.
2. Завести глобальный счетчик операций и просто перестраивать целую структуру каждые `q` запросов (выписать обратно в массив и заново разделить на равные блоки).

В первом случае мы потенциально тратим `O(n)` операций на сплиты и мерджи, но гарантируем инварианты, а во втором получаем ровно `O(n)` помножить на стоимость построения.

Второй вариант проще кодить (ведь структуру в любом случае нужно изначально строить). Примечательно, что бывают ситуации, когда перестраивать структуру не так выгодно, как поддерживать в сбалансированном состоянии — когда мердж дешевле перестроения с нуля.

