# Название

Поиск горячих зон загрязнённости воздуха и нормализация карты

# Описание

**Дано:**

- Двумерный массив airMap[M][N], где airMap[i][j] — уровень загрязнённости воздуха в точке (i,j) (целые числа от 0 до 500).
- Целое число K — размер стороны квадратной зоны для анализа.
- Целое число T — порог среднего загрязнения.

**Необходимо:**

- Найти все квадратные зоны размером K×K на карте airMap, где средний уровень загрязнённости воздуха максимален.
- Среди найденных зон оставить только те, где среднее значение загрязнённости больше или равно порогу T.
- Построить новую карту normalizedMap того же размера, нормализовав значения исходной карты airMap в диапазон от 0 до 1 с помощью мин–макс нормализации.

**Требуемый вывод:**

- Список координат верхнего левого угла всех зон K×K, удовлетворяющих условию.
- Двумерный массив normalizedMap[M][N] с нормализованными значениями, округлёнными до двух знаков после запятой.

# Краткая теория

---
title: Арифметика
weight: 2
authors:
- Бобровская Анна
created: 2025
---

## Арифметика и битовое представление

### Битовое представление целых чисел
Все целые числа могут быть записаны в двоичной системе счисления:  

5₁₀ = 101₂ = 4 + 1
42₁₀ = 101010₂ = 32 + 8 + 2
256₁₀ = 100000000₂ = 2^8

На аппаратном уровне компьютер хранит числа в виде битовых слов фиксированной длины: 8 бит (`char`), 16 бит (`short`), 32 бит (`int`) или 64 бит (`long long`).  

---

### Эндианность
Порядок байтов при хранении числа в памяти может отличаться в зависимости от архитектуры. Эта особенность называется **эндианностью**.  

- **Little-endian** — младшие байты записываются первыми.  
- **Big-endian** — старшие байты записываются первыми.  

---

### Побитовые операции

#### Сдвиги
Битовое представление можно сдвигать:  

- `x << y` — сдвиг влево, эквивалент умножению на 2^y  
- `x >> y` — сдвиг вправо, эквивалент целочисленному делению на 2^y (с округлением вниз)  

Сдвиги работают очень быстро — за один такт процессора — поэтому умножение или деление на степень двойки часто оптимизируется именно так.  

#### Логические побитовые операции
Побитовые версии логических операций применяются отдельно к каждому биту:  

- AND  
- OR  
- NOT  
- XOR  

Примеры:

13 & 7 = 1101₂ & 0111₂ = 0101₂ = 5
17 | 10 = 10001₂ | 01010₂ = 11011₂ = 27
17 ^ 9 = 10001₂ ^ 01001₂ = 11000₂ = 24

---
### Маски и подмножества

Бинарное число можно рассматривать как представление множества: если i-й бит равен 1, элемент i входит в множество, иначе — нет. Побитовые операции позволяют эффективно работать с такими множествами.

- **Установка i-го бита:** `x |= (1 << i)` — добавляет элемент в множество.  
- **Инверсия i-го бита:** `x ^= (1 << i)` — меняет состояние элемента (если был в множестве — убирает, если не был — добавляет).

Пример:  

```cpp
int x = 5;        // 0101₂
bool bit2 = (x >> 2) & 1; // проверка 2-го бита -> 1
x |= (1 << 1);    // установка 1-го бита -> 0111₂ = 7
x &= ~(1 << 0);   // сброс 0-го бита -> 0110₂ = 6
x ^= (1 << 2);    // инверсия 2-го бита -> 0010₂ = 2

