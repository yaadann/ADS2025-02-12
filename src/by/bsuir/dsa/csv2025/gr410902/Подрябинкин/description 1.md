# Название

Управление мощностью ТЭЦ

# Описание

Управление мощностью ТЭЦ

Ваша задача найти минимальный расход на эксплуатацию котла электростанции под заданные условия и вывести его. В начале дня вам даётся массив int D[] в котором расписано по часам, какую минимальную мощность должен производить ваш котёл. 
#### У котла есть следующие характеристики:
- Изначально мощность котла 0Вт (не запущен) 
- Стоимость запуска 10 у.е. (не поднимет мощность, тратится только на запуск из нулевой мощности)
- Стоимость изменения мощности котла на 1Вт 20 у.е.
- Стоимость работы котла за 1 час на мощности p равна p^2 у.е.;
- Смена мощности осуществляется мгновенно в начале часа, но не более чем на 5 единиц
#### Ограничения по данным следующие:
- Количество часов: не более 24 (Размер массива D[])
- Максимальная мощность котла 20Вт
- Число 90000 считается бесконечностью
## Формат данных
- на вход подаётся String в котором записаны int через пробел (например "0 5 10")
- количество часов 0 < D[].size < 24
- Мощность 0 < D[i] < 20
## Формат вывода
- String с числом минимальной стоимости эксплуатации по заданному графику. (Если график мощности не выполним, вернуть бесконечность т.е. "90000")

## Требование
Задачу необходимо реализовать динамическим программированием через реализацию по слоям (Оптимизации необязательны).

P.S. Котёл в задаче абстрактный, большие расходы на изменение мощности считать бюрократией.

## Шаблон решения
```java
import java.util.Scanner;
public class Main {
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        String test_data = sc.nextLine();
        if(test_data == "") return;
        String output_data = StationGraphic(test_data);
        System.out.println(output_data);
        sc.close();
    }

    public static String StationGraphic(String input){

        //Перегоняет вход String в int[]
        String[] parts = input.split(" ");
        int[] D = new int[parts.length]; //Массив входных данных
        for (int i = 0; i < parts.length; i++) {
            D[i] = Integer.parseInt(parts[i]);
        }
        String result = ""; //Результат на вывод
        //Константы задачи
        int time = D.length; //Количество часов работы (в задаче рекомендую добавить +1 час до запуска)
        int p_max = 20; //Максимальная мощность котла
        int start_cost = 10; //Стоимость запуска котла из состояния нулевой мощности
        int delta_p_cost = 20; //Стоимость изменения мощности на 1Вт
        //Стоимость работы 1 час на мощности p: p^2
        int max_delta_p = 5; //Максимально допустимое изменение мощности в начале часа
        int INF = 90000; //Условная бесконечность в задаче
        //============Решение==============

        //============Конец решения==============


        return result;
    }

    
    public String runTest(String input){
        System.setIn(new ByteArrayInputStream(input.getBytes()));
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        System.setOut(new PrintStream(output));
        Main.main(new String[]{});
        String result = output.toString().trim();
        return result;
    }
    //Тест для проверки вашего кода
    @Test
    public void RunAllTests() throws Exception {
        assertEquals("135", runTest("0 0 5\n"));
        assertEquals("160", runTest("0 5 0\n"));
        assertEquals("335", runTest("0 0 10\n"));
        assertEquals("202", runTest("5 0 0 0\n"));
        assertEquals("577", runTest("0 10 5 5 5 0 0 0\n"));
        assertEquals("577", runTest("0 10 5 5 5 3 1 1\n"));
        assertEquals("90000", runTest("20\n"));
        assertEquals("360", runTest("5 0 10\n"));
        assertEquals("1160", runTest("0 5 10 20\n"));
        assertEquals("202", runTest("5 1 1 1\n"));
        assertEquals("1160", runTest("0 0 0 20\n"));
        assertEquals("202", runTest("5 0 0 2\n"));
    }
}
```

Пример 1:
- Ввод: "0 0 5"
- Вывод:  "135"
- Оптимальный режим 0->0->5

Пример 2:
- Ввод: "0 5 0"
- Вывод: "160"
- Оптимальный режим 0->5->5

# Краткая теория

---
title: Пересчет динамики по слоям
authors:
- Сергей Слотин
- Константин Амеличев
created: 2019
updated: 2021-08-29
---
---
# Пересчет динамики по слоям

Задача. Даны \(n\) точек на прямой, отсортированные по своей координате \(x_i\).  
Нужно найти \(m\) отрезков, покрывающих все точки, минимизировав при этом сумму квадратов их длин.

Базовое решение — определить состояние динамики \(f[i,j]\)  
как минимальную стоимость покрытия \(i\) первых точек, используя не более \(j\) отрезков.  
Пересчитывать её можно перебором всех возможных последних отрезков:

$$
f[i,j] = \min_{k < i} \left\{ f[k, j-1] + (x_{i-1} - x_k)^2 \right\}.
$$

Итоговым ответом будет \(f[n,m]\), а суммарно такая динамика будет работать за \(O(n^2 m)\).

```cpp
// x[] — отсортированный массив координат точек, индексация с нуля

// квадрат длины отрезка с i-той до j-той точки
int cost(int i, int j) {
    return (x[j] - x[i]) * (x[j] - x[i]);
}

for (int i = 0; i <= m; i++)
    f[0][i] = 0; // если нам не нужно ничего покрывать, то всё и так хорошо
// все остальные f предполагаем равными бесконечности

for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
        for (int k = 0; k < i; k++)
            f[i][j] = min(f[i][j], f[k][j - 1] + cost(k, i - 1));
// (Заметим, что циклы по i и j можно поменять местами.)

```
---
# Адаптация теории к задаче экзамена
//данная часть написана студентом

В примере двумерный массив \(f[n,m]\) работает постоянно в режиме двух слоёв. Если переставить местами циклы с i и j, то окажется, что за один внешний цикл задействуется только 2 "слоя" массива (j и j-1).
```cpp

for (int j = 1; j <= m; j++)
    for (int i = j; i <=n; i++)
        for (int k = 0; k < i; k++)
            f[i][j] = min(f[i][j], f[k][j - 1] + cost(k, i - 1));
// (Заметим, что циклы по i и j можно поменять местами.)  <---
```
В теории это позволяет оптимизировать память с O(n*m) до 2 * O(n), создав 2 массива, которые будут отвечать за эти слои. Однако главной идеей такого метода является решение каждого нового состояния через предыдущее, с выбором оптимального в последнем слое. Именно эта идея пригодится вам в реализации задачи про минимальную стоимость работы электростанции.

