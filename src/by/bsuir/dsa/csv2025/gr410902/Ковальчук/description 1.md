# Название

Декартово дерево с поддержкой повторяющихся ключей

# Описание

Задача: Декартово дерево с поддержкой повторяющихся ключей

## Постановка задачи

Требуется реализовать модифицированную версию декартова дерева, способную эффективно обрабатывать операции над мультимножеством целых чисел с поддержкой статистических запросов.

## Техническое задание

Разработать структуру данных на основе декартова дерева, обеспечивающую выполнение следующих операций:

- **insert x** - добавление элемента x в мультимножество
- **erase x** - удаление одного вхождения элемента x из мультимножества  
- **count x** - подсчет количества вхождений элемента x
- **sum L R** - вычисление суммы всех элементов в диапазоне [L, R]
- **kth k** - нахождение k-го элемента в отсортированном порядке мультимножества
- **next x** - поиск минимального элемента, строго большего x
- **prev x** - поиск максимального элемента, строго меньшего x

## Спецификация требований

### Функциональные требования

1. **Поддержка дубликатов**: Структура должна корректно обрабатывать повторяющиеся ключи, сохраняя информацию о количестве вхождений каждого элемента.

2. **Эффективность операций**: Все операции должны выполняться за логарифмическое время относительно размера мультимножества в среднем случае.

3. **Статистические запросы**: Обеспечить корректную работу запросов на диапазоны и порядковую статистику с учетом повторяющихся элементов.

4. **Обработка граничных значений**: Корректная работа с минимальными и максимальными целочисленными значениями, пустыми множествами и несуществующими элементами.

### Структурные требования

1. **Узел дерева** должен содержать:
   - Ключ (key)
   - Приоритет (priority) для поддержки свойства кучи
   - Счетчик повторений (count)
   - Сумму поддерева (sum)
   - Размер поддерева (size)
   - Ссылки на потомков

2. **Операция split** должна разделять дерево по ключу с сохранением свойств декартова дерева.

3. **Операция merge** должна объединять два декартовых дерева в одно.

4. **Обновление метаданных** должно происходить при каждой модификации структуры.

## Особенности реализации

### Учет повторяющихся элементов

В отличие от классического декартова дерева, где каждый ключ уникален, в данной реализации:
- При вставке существующего ключа увеличивается счетчик повторений
- При удалении уменьшается счетчик, узел удаляется только при достижении нуля
- Все статистические операции учитывают множественные вхождения

### Обработка больших чисел

- Для сумм используется тип `long` для предотвращения переполнения
- Особое внимание уделено операциям с крайними значениями целочисленного диапазона

## Формат входных данных

Первая строка содержит целое число `n` - количество операций.

Далее следует `n` строк, каждая из которых представляет одну операцию в формате:
- `insert x`
- `erase x` 
- `count x`
- `sum L R`
- `kth k`
- `next x`
- `prev x`

где `x`, `L`, `R`, `k` - целые числа.

### Пример входных данных: 
                7
                1 5
                1 3
                1 5
                3 5
                3 3
                3 1
                3 6
## Формат выходных данных

Для каждой операции `count`, `sum`, `kth`, `next`, `prev` выводится результат выполнения.

Результаты выводятся в одной строке, разделенные пробелами, в порядке выполнения операций.

### Пример выходных данных: 2 1 0 0

# Краткая теория

---
title: Декартово дерево
weight: 3
authors:
- Андрей
created: 2025
---

## Определение

**Декартово дерево (treap, дерамида)** — структура данных, которая объединяет:
- свойства *бинарного дерева поиска* по ключу `x`;
- свойства *кучи* по приоритету `y`.

Каждый узел хранит пару `(x, y)`:
- в левом поддереве ключи меньше `x`;
- в правом поддереве ключи больше `x`;
- приоритеты образуют кучу: у родителя приоритет меньше, чем у потомков.

## Свойства

- Среднее время операций:
  - Поиск: $O(\log n)$
  - Вставка: $O(\log n)$
  - Удаление: $O(\log n)$
- Построение дерева из массива: $O(n)$
- Балансировка достигается случайным выбором приоритетов.

## Основные операции

### Split
Разделяет дерево `T` на два:
- `L` с ключами ≤ `x`
- `R` с ключами > `x`

**Формула:**


\[
T = L \cup R,\quad \max(L) \leq x < \min(R)
\]



---

### Merge
Объединяет два дерева, где все ключи в `L` меньше ключей в `R`.

**Формула:**


\[
\forall u \in L, v \in R: u.key < v.key
\]



---

### Insert
Вставка узла `(x, y)`:
- Использует `split` и `merge`.
- Балансировка сохраняется автоматически.

**Формула:**


\[
Insert(T, (x,y)) = Merge(Merge(L, newNode), R), \quad (L,R) = Split(T, x)
\]



---

### Erase
Удаление узла по ключу:
- Находит узел.
- Сливает его левое и правое поддеревья.

**Формула:**


\[
Erase(T, x) = Merge(T.left, T.right)
\]



---

## Формулы и оценки

- Средняя глубина узла:


\[
E[depth] = O(\log n)
\]



- Вероятность плохой балансировки:


\[
P(\text{глубина} > c \cdot \log n) \to 0 \quad \text{при } n \to \infty
\]



---

## Применение

- Быстрая реализация динамических множеств.  
- Поддержка операций над массивами (например, работа с подотрезками).  
- Используется в задачах на онлайн-обработку данных и сбалансированные структуры.


