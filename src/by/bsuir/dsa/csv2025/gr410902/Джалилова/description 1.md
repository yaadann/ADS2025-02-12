# Название

Соединение серверов

# Описание

Соединение серверов

В вычислительной системе имеется **n серверов**, каждому из которых присвоен номер от 1 до n.

Связь между двумя серверами считается существующей, если найдётся некоторое число **k**, большее порогового значения **threshold**, такое что номера обоих серверов делятся на **k** без остатка. В этом случае серверы могут обмениваться данными напрямую.

Кроме прямого соединения допускается и **косвенная связь**: если сервер A связан с сервером B, а сервер B с сервером C, то A и C также считаются связанными, даже если общего числа **k** у них напрямую нет.

## Входные данные

- Первая строка содержит два целых числа **n** и **threshold** — количество серверов и минимальное значение делителя, способного образовать соединение.
- Вторая строка содержит одно целое число **q** — количество запросов.
- Далее следуют **q** строк, каждая из которых содержит два числа **ai** и **bi** — номера серверов, для которых требуется определить, находятся ли они в одной связной группе.

## Выходные данные

Для каждого запроса необходимо вывести **true**, если сервера могут обмениваться данными (напрямую или через цепочку других серверов), и **false** в противном случае. Каждый ответ выводится с новой строки.


# Краткая теория

Реализация системы непересекающихся множеств (Disjoint Set)

## Обзор

При решении задач, связанных с компонентами связности или разделением элементов на отдельные группы, эффективное отслеживание этих отношений имеет важное значение. Структура данных Disjoint Set Union (DSU), также известная как структура данных Union-Find, предлагает элегантное решение.

## Основы системы непересекающихся множеств (DSU)

Система непересекающихся множеств - это структура данных, предназначенная для управления коллекцией непересекающихся множеств. Ее сила заключается в двух основных операциях:
- **find**: определение того, к какому множеству принадлежит элемент
- **union**: объединение двух различных множеств

Рассмотрим отслеживание компонент связности в графе. Изначально каждая вершина находится в своем собственном множестве. При обработке ребра между вершиной u и вершиной v вы используете `union(u, v)` для объединения их соответствующих множеств, эффективно указывая, что они теперь связаны.

## Полная реализация на Java

```java
public class DisjointSet {
    private int[] parent;
    private int[] rank;
    private int count; // количество непересекающихся множеств

    public DisjointSet(int n) {
        if (n <= 0) {
            throw new IllegalArgumentException("Количество элементов должно быть положительным");
        }
        
        parent = new int[n];
        rank = new int[n];
        count = n;
        
        // Инициализируем каждый элемент как своего собственного родителя
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            rank[i] = 0; // Начальный ранг равен 0
        }
    }

    /**
     * Операция find со сжатием пути
     * Временная сложность: O(α(n)) - почти постоянная
     */
    public int find(int i) {
        if (i < 0 || i >= parent.length) {
            throw new IllegalArgumentException("Неверный индекс элемента: " + i);
        }
        
        // Сжатие пути: заставляем каждый узел указывать непосредственно на корень
        if (parent[i] != i) {
            parent[i] = find(parent[i]);
        }
        return parent[i];
    }

    /**
     * Операция union с объединением по рангу
     * Временная сложность: O(α(n)) - почти постоянная
     */
    public void union(int i, int j) {
        if (i < 0 || i >= parent.length || j < 0 || j >= parent.length) {
            throw new IllegalArgumentException("Неверные индексы элементов");
        }
        
        int rootI = find(i);
        int rootJ = find(j);
        
        // Если уже в одном множестве, объединение не требуется
        if (rootI == rootJ) {
            return;
        }
        
        // Объединение по рангу: присоединяем дерево с меньшим рангом к корню дерева с большим рангом
        if (rank[rootI] < rank[rootJ]) {
            parent[rootI] = rootJ;
        } else if (rank[rootI] > rank[rootJ]) {
            parent[rootJ] = rootI;
        } else {
            // Если ранги одинаковы, делаем один корнем и увеличиваем его ранг
            parent[rootJ] = rootI;
            rank[rootI]++;
        }
        
        count--; // Уменьшаем количество непересекающихся множеств
    }

    /**
     * Проверить, связаны ли два элемента
     */
    public boolean isConnected(int i, int j) {
        return find(i) == find(j);
    }

    /**
     * Получить количество непересекающихся множеств
     */
    public int getCount() {
        return count;
    }

    /**
     * Получить размер каждой компоненты
     */
    public int getComponentSize(int i) {
        int root = find(i);
        int size = 0;
        for (int j = 0; j < parent.length; j++) {
            if (find(j) == root) {
                size++;
            }
        }
        return size;
    }
}
```

