# Название

Восстановление состояния сортировки выбором после k обменов

# Описание

Восстановление состояния сортировки выбором после k обменов

## Задача  
Даны два массива одинаковой длины:  
- исходный массив **A**,  
- массив **B**, который представляет собой состояние массива **после ровно k обменов**, выполненных алгоритмом сортировки выбором над **A**.  

При этом число **k неизвестно**.

## Требуется  
Определить **все возможные значения k**, при которых классическая сортировка выбором, выполняемая над массивом **A**, могла привести к массиву **B** после ровно **k обменов**, то есть в некоторый момент выполнения алгоритма до его окончания.

Если таких значений не существует, следует вывести пустой список.

## Особенности  
- Сортировка выбором на итерации `i` находит минимум на отрезке `[i..n−1]` и выполняет один обмен с позицией `i`, если элемент на позиции `i` не является минимумом.  
- Массив **B** — это **промежуточное состояние**, а не окончательно отсортированный массив.  
- Полная симуляция алгоритма за `O(n²)` недопустима при больших n.  
- Требуется решение с асимптотикой не хуже `O(n log n)`.

## Формат входных данных  
Даны два массива `A` и `B` одинаковой длины `n`.

Пример:
A = [5, 3, 4, 1, 2]
B = [1, 3, 4, 5, 2]

## Формат выходных данных  
Выведите все возможные значения `k` в порядке возрастания.

Пример:


## Формат выходных данных  
Выведите все возможные значения `k` в порядке возрастания.

Пример:

[1, 4]


## Пояснение  
При выполнении сортировки выбором над массивом `A`, массив становится равным `B` после первого обмена, а также после четвертого обмена. Поэтому корректные значения `k` — `1` и `4`.

# Краткая теория

## Краткая теория

Алгоритм сортировки выбором работает следующим образом:  
на каждой итерации `i` он находит минимальный элемент на подотрезке `[i..n−1]` и при необходимости выполняет **ровно один обмен** — ставит этот минимум на позицию `i`.

### Ключевые свойства
- После итерации `i` позиция `i` всегда содержит **минимум суффикса**, и это состояние окончательно.
- Количество обменов равно количеству индексов `i`, для которых текущий элемент не является минимумом суффикса.
- После каждого обмена изменяются **строго две позиции**, и это создаёт уникальную последовательность промежуточных состояний.
- Промежуточное состояние массива полностью определяется последовательностью уже выполненных обменов.

### Почему задача сложная
- Полностью симулировать сортировку нельзя — это `O(n²)`.
- Нужно понять, могло ли состояние массива **B** появиться после некоторого количества обменов.
- Для этого требуется анализировать:
  - минимумы на всех суффиксах,
  - порядок перемещения минимальных элементов,
  - соответствие результата ровно `k` уникальным обменам.

Таким образом, решение требует не моделирования сортировки, а восстановления логики обменов и проверки, на каких шагах массив мог совпасть с состоянием `B`.


