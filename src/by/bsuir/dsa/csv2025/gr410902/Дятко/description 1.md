# Название

Минимальное разбиение строки на слова словаря с использованием префиксного дерева и динамического программирования

# Описание

Минимальное разбиение строки на слова словаря с использованием префиксного дерева и динамического программирования

В консоль будет передано три строки:
1. Количество слов в словаре
2. Слова словаря, разделённые пробелами
3. Строка, которую нужно разбить

Не используя встроенные классы, необходимо:
- Считать входные данные из консоли
- Построить префиксное дерево (Trie) на основе слов словаря
- Найти минимальное количество разбиений строки на слова из словаря с помощью динамического программирования

Выведите в консоль результат — минимальное количество разбиений.

### Пример входных данных:
```txt
3
aaa aa b
aaab
```
### Пример вывода:
```txt
2
```

# Краткая теория

Префиксное дерево

**Авторы:** Сергей Слотин, Глеб Лобанов  

Префиксное дерево или бор (англ. *trie*) — структура данных для компактного хранения строк, устроенная в виде дерева, где на рёбрах между вершинами записаны символы, а некоторые вершины помечены терминальными.

Говорят, что префиксное дерево принимает строку `s`, если существует такая терминальная вершина `v`, что, если выписать подряд все буквы на пути от корня до `v`, получится строка `s`.

## Применения

- **Хранение строк.** Если есть много повторяющихся длинных префиксов, бор может занимать гораздо меньше места, чем массив или `set` строк.
- **Сортировка строк.** По построенному бору можно пройтись DFS-ом и вывести все строки в лексикографическом порядке.
- **Множество строк.** В бор легко добавлять и удалять слова, а также делать проверки вхождения.

С точки зрения теории автоматов, каждая вершина — это состояние, а все корректные односимвольные дополнения — корректные переходы. Таким образом, бор — это автомат, проверяющий вхождение слова в множество.

## Реализация

Префиксное дерево удобно хранить в виде ссылающихся друг на друга вершин. В каждой вершине обычно хранятся:

- флаг терминальности,
- ссылки на детей,
- дополнительная информация (например, количество слов, заканчивающихся в вершине — для реализации мультисета).

Для латинского алфавита (26 строчных букв) пустой бор можно реализовать так:

```cpp
const int k = 26;

struct Vertex {
    Vertex* to[k] = {0}; // нулевой указатель означает отсутствие перехода
    bool terminal = false;
};

Vertex* root = new Vertex();
```

