# Название

Поиск подстроки с использованием префикс-функции

# Описание

Поиск подстроки с использованием префикс-функции

## Условие задачи

Дана строка `s` и подстрока `pattern`. Требуется найти все вхождения подстроки `pattern` в строку `s` с использованием алгоритма Кнута-Морриса-Пратта (KMP), основанного на префикс-функции.

**Задача:** Для заданной строки `s` и подстроки `pattern`:
1. Вычислить префикс-функцию для подстроки `pattern`
2. Найти все позиции в строке `s`, где начинается подстрока `pattern`
3. Вывести результаты в требуемом формате

## Требования

1. Изучить теоретические основы префикс-функции
2. Понять алгоритм Кнута-Морриса-Пратта для поиска подстроки
3. Разработать алгоритм вычисления префикс-функции
4. Реализовать поиск всех вхождений подстроки
5. Привести примеры работы алгоритма

## Формат решения

- Математическое определение префикс-функции
- Алгоритм вычисления префикс-функции
- Алгоритм поиска подстроки с использованием префикс-функции
- Примеры для различных строк и подстрок

---

### Особенности этой задачи:

- **Фундаментальный алгоритм** - префикс-функция является основой многих алгоритмов на строках
- **Эффективность** - алгоритм KMP работает за O(n + m) времени, где n - длина строки, m - длина подстроки
- **Практическое применение** - поиск подстроки используется в текстовых редакторах, поисковых системах, обработке ДНК
- **Хороша для изучения** - позволяет понять важные концепции работы со строками

Эта задача отлично подходит для изучения алгоритмов на строках и понимания принципов оптимизации поиска подстроки.


# Краткая теория

---
author: Стефанович Ярослав
weight: 1
---

# Поиск подстроки с использованием префикс-функции

## Условие задачи

Дана строка `s` и подстрока `pattern`. Требуется найти все вхождения подстроки `pattern` в строку `s` с использованием алгоритма Кнута-Морриса-Пратта (KMP), основанного на префикс-функции.

## Теоретический анализ

### Основные понятия

**Определение.** Для строки `s` длины `n` префикс-функция `π[i]` (0 ≤ i < n) определяется как длина наибольшего собственного суффикса подстроки `s[0..i]`, который одновременно является префиксом этой подстроки.

**Формально:** 
```
π[i] = max{k : 0 ≤ k < i, s[0..k-1] = s[i-k+1..i]}
```

где `s[0..k-1]` обозначает префикс строки `s` длины `k`, а `s[i-k+1..i]` - суффикс подстроки `s[0..i]` длины `k`.

**Важные свойства:**
- `π[0] = 0` (для строки из одного символа нет собственного суффикса)
- `π[i] < i` для всех `i > 0` (собственный суффикс короче всей подстроки)
- Если `s[0..i]` имеет период длины `p`, то `π[i] ≥ i - p + 1`

### Рекуррентное вычисление префикс-функции

**Основная идея:** При вычислении `π[i]` мы используем уже вычисленные значения `π[0], π[1], ..., π[i-1]`.

**Алгоритм вычисления:**

```
π[0] = 0
for i from 1 to n-1:
    j = π[i-1]
    while j > 0 and s[i] ≠ s[j]:
        j = π[j-1]
    if s[i] == s[j]:
        π[i] = j + 1
    else:
        π[i] = 0
```

**Корректность алгоритма:**

Пусть мы вычисляем `π[i]`. По определению, `π[i-1]` - это длина наибольшего собственного суффикса `s[0..i-1]`, который является префиксом.

Если `s[i] == s[π[i-1]]`, то мы можем просто расширить найденный префикс-суффикс, добавив символ `s[i]`. В этом случае `π[i] = π[i-1] + 1`.

Если `s[i] ≠ s[π[i-1]]`, то нам нужно найти меньший префикс-суффикс. Ключевое наблюдение: следующий кандидат на префикс-суффикс имеет длину `π[π[i-1]-1]`. Это следует из того, что если `s[0..k-1]` является суффиксом `s[0..i-1]`, то наибольший собственный префикс-суффикс `s[0..k-1]` также является суффиксом `s[0..i-1]`.

**Временная сложность:** O(n), так как каждая итерация внутреннего цикла `while` уменьшает значение `j`, и `j` не может стать отрицательным.

### Алгоритм Кнута-Морриса-Пратта

**Идея алгоритма:** Используя префикс-функцию для подстроки `pattern`, мы можем избежать возврата указателя в строке `s` при несовпадении символов.

**Алгоритм поиска:**

```
1. Вычислить префикс-функцию π для pattern
2. j = 0  // указатель в pattern
3. for i from 0 to |s|-1:
       while j > 0 and s[i] ≠ pattern[j]:
           j = π[j-1]  // сдвигаем pattern, используя префикс-функцию
       if s[i] == pattern[j]:
           j++
       if j == |pattern|:
           // найдено вхождение на позиции i - |pattern| + 1
           j = π[j-1]  // продолжаем поиск следующего вхождения
```

**Корректность:**

Когда `s[i] ≠ pattern[j]`, вместо возврата указателя `i` в строке `s`, мы используем префикс-функцию, чтобы найти наибольший префикс `pattern`, который является суффиксом `pattern[0..j-1]`. Это позволяет нам продолжить сравнение с позиции `j = π[j-1]`, не возвращаясь назад в строке `s`.

**Временная сложность:** O(n + m), где n - длина строки `s`, m - длина подстроки `pattern`.

**Пространственная сложность:** O(m) для хранения префикс-функции.

## Алгоритмический анализ

### Вычислительная модель

Алгоритм KMP можно представить как конечный автомат, где:
- Состояния соответствуют позициям в `pattern`
- Переходы определяются префикс-функцией
- Принятие происходит при достижении конечного состояния (полном совпадении)

### Оптимальность алгоритма

Алгоритм KMP является оптимальным для задачи поиска подстроки в худшем случае среди алгоритмов, которые не используют предобработку строки `s`. 

**Нижняя оценка:** Любой алгоритм поиска подстроки должен проверить каждый символ строки `s` хотя бы один раз, что дает нижнюю оценку Ω(n). Алгоритм KMP достигает этой оценки с точностью до константы.

### Сравнение с наивным алгоритмом

**Наивный алгоритм:**
- Временная сложность: O(n·m) в худшем случае
- Пространственная сложность: O(1)
- Простота реализации

**Алгоритм KMP:**
- Временная сложность: O(n + m)
- Пространственная сложность: O(m)
- Более сложная реализация, но значительно быстрее для длинных строк

## Теоретические обобщения

### Z-функция

Альтернативный подход к поиску подстроки использует Z-функцию, которая для строки `s` определяется как:
```
Z[i] = max{k : s[0..k-1] = s[i..i+k-1]}
```

Z-функция и префикс-функция тесно связаны и могут быть преобразованы друг в друга.

### Автоматное программирование

Алгоритм KMP можно интерпретировать как построение детерминированного конечного автомата (DFA) для поиска подстроки. Это открывает путь к обобщению на поиск нескольких подстрок одновременно (алгоритм Ахо-Корасик).

### Применения префикс-функции

1. **Поиск подстроки** - основное применение
2. **Поиск периода строки** - строка имеет период `p`, если `π[n-1] ≥ n - p`
3. **Сжатие строк** - использование префикс-функции для обнаружения повторяющихся паттернов
4. **Обработка ДНК** - поиск генетических последовательностей

## Связь с другими алгоритмами

### Алгоритм Рабина-Карпа

Алгоритм Рабина-Карпа использует хеширование для поиска подстроки. В среднем случае он работает за O(n + m), но в худшем случае может деградировать до O(n·m). KMP гарантирует O(n + m) в худшем случае.

### Алгоритм Бойера-Мура

Алгоритм Бойера-Мура использует эвристику "плохого символа" и "хорошего суффикса". На практике он часто быстрее KMP, особенно для длинных подстрок, но сложнее в реализации.

### Алгоритм Ахо-Корасик

Обобщение KMP для поиска множества подстрок одновременно. Использует префикс-функцию в структуре данных trie.

## Заключение

Префикс-функция и алгоритм KMP представляют собой фундаментальные инструменты в алгоритмах на строках. Понимание этих концепций открывает путь к изучению более сложных алгоритмов, таких как алгоритм Ахо-Корасик, и имеет широкое практическое применение в обработке текста, биоинформатике и системах поиска.

Полученные знания имеют практическое значение в разработке текстовых редакторов, поисковых систем, антивирусного программного обеспечения и систем обработки генетических данных.


