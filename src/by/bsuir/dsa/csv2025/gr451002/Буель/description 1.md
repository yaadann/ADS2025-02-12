# Название

K-ый элемент в BST

# Описание

Представь себе книжную полку, на которой книги стоят строго по алфавиту по фамилии автора.
Когда приходит новая книга, библиотекарь вставляет её ровно в то место, где она должна стоять по алфавиту — не в конец и не в начало.

Получается такая структура, где:
1. слева стоят книги «меньше» (по алфавиту),
2. справа — книги «больше».

Если читателю нужна, скажем, 5-я книга по порядку, библиотекарь не считает все книги подряд.
Он идёт так:
1. Смотрит на какую-то «центральную» книгу.
2. Понимает — если нужная раньше по алфавиту, идёт влево, если позже — вправо.
3. И так пока не найдёт нужную позицию.

Эта книжная полка — аналог Дерева Бинарного Поиска (BST), а задача найти k-ую книгу — это находжение k-го наименьшего элемента в BST.

k всегда будет действительным индексом, что означает 1 ≤ k ≤ (Количество узлов в дереве).

Ввод состоит из 2 строк:
1. Значения узлов в дереве
2. Индекс k

Примеры
Ввод:
2 2 4 1 3
1
Вывод: 1

Пояснение: (1) 2 3 4

# Краткая теория

Дерево Бинарного Поиска (Binary Search Tree, BST) — это структура данных, которая хранит элементы в виде дерева таким образом, чтобы можно было быстро выполнять поиск, вставку и сортировку.

# Основное свойство BST

## Для каждого узла дерева выполняется:
1. все значения левого поддерева меньше значения узла,
2. все значения правого поддерева больше значения узла.

Это позволяет искать элементы за время порядка O(log n) в сбалансированном дереве.

# Построение дерева

## При вставке каждого числа:
1. если число меньше текущего узла → идём влево;
2. если больше → вправо;
3. когда упираемся в пустую позицию — создаём там новый узел.

Так строится дерево по входным данным.

# Поиск k-го наименьшего элемента

## Очень важное свойство BST:
Если сделать обход дерева в порядке обхода “лево → корень → право” (in-order traversal), то мы получим все элементы по возрастанию.

То есть, если мы обойдём дерево in-order, то:
1.Сначала соберём всё левое поддерево
2.Потом текущий узел
3.Потом правое поддерево

