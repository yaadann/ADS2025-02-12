# Название

Контроль качества расшифровок с помощью префикс-функции

# Описание

Контроль качества расшифровок с помощью префикс-функции

## Условие задачи

Команда транскрибирования сервиса «Слушай.Онлайн» круглосуточно расшифровывает аудио от операторов экстренной линии. В каждой расшифровке нужно моментально отмечать появление триггерной фразы `ПАСПОРТ ЗАБЛОКИРОВАН`, чтобы подключить специалиста по fraud-рискам. Ручной просмотр и наивный поиск буква за буквой не масштабируются при тысячах строк в минуту. Поэтому инженеры внедряют поиск подстроки через префикс-функцию, как описано на https://ru.algorithmica.org/cs/string-searching/prefix-function/.

**Задача:** по заданным шаблону и тексту (оба допускают пробелы и спецсимволы) определить все позиции начала вхождения шаблона в тексте. Используйте линейный алгоритм на основе префикс-функции и обоснуйте его корректность.

## Требования

1. Пересказать определение префикс-функции `pi[i]` и идею переиспользования совпавших префиксов/суффиксов (см. материал Algorithmica).
2. Доказать ограничение роста `pi[i] ≤ pi[i-1] + 1` и объяснить, как оно ускоряет «откат» индекса.
3. Объяснить, зачем строится строка `pattern + "#" + text`, почему символ-разделитель выбирают уникальным и как по значениям `pi` находят вхождения.
4. Проанализировать время и память: `O(n + m)` по длинам текста и шаблона при `O(1)` дополнительной памяти на символы.
5. Подготовить консольные примеры без совпадений, с единичным совпадением и с перекрывающимися совпадениями, опираясь на реальный сценарий мониторинга расшифровок.

## Формат решения

- Теоретическое эссе с пошаговым расчётом префикс-функции и ссылкой на исходный материал.
- Рабочий код (или псевдокод) вычисления `pi` и поиска всех позиций вхождений.
- Набор примеров, отражающих триггерную фразу службы контроля качества.

---

### Особенности этой задачи:

- **Реальный контекст** — поток расшифровок и тревожные фразы fraud-аналитиков.
- **Практика строк** — акцент на линейном поиске подстроки вместо игр и головоломок.
- **Переход к КМП** — префикс-функция как базовый кирпич для полного алгоритма Кнута–Морриса–Пратта.
- **Поведенческие тесты** — проверяются и пустые результаты, и перекрывающиеся сигналы.

Задача подходит разработчикам, которые хотят подкрепить теорию строки примерами из продуктовой аналитики и быстро перейти к промышленному распознаванию паттернов.

# Краткая теория

---
author: Николай Курейчик
weight: 1
---

# Префикс-функция как основа мониторинга транскриптов

Материал основан на конспекте https://ru.algorithmica.org/cs/string-searching/prefix-function/ и адаптирован под задачу службы контроля качества, которая ищет фразы-триггеры во входящем потоке расшифрованных звонков.

## Постановка

Есть шаблон `P` длины `m` и текст `T` длины `n`. Требуется найти все индексы `i`, где `T[i..i+m-1] = P`. В отличие от наивного алгоритма `O(n·m)`, нам нужен линейный по `n + m` подход, который устойчиво работает на потоке расшифровок.

## Определение префикс-функции

Для строки `S` определим `pi[i]` как длину наибольшего собственного префикса `S`, совпадающего с суффиксом, заканчивающимся в позиции `i`. По сути `pi[i]` показывает, сколько символов мы уже «узнали» при просмотре строки слева направо. Согласно доказательству из статьи Algorithmica, последовательность `pi` удовлетворяет ограничению

```
pi[i] ≤ pi[i-1] + 1
```

Пояснение: если предыдущие `pi[i-1]` символов уже образуют границу, то на позиции `i` мы можем либо расширить её максимум на один символ, либо «откатиться» к более короткой границе, используя предыдущее значение `pi`. Благодаря этому ограничению цикл пересчёта остаётся линейным.

## Как вычислять `pi`

Алгоритм односкановый:

1. Стартуем с `pi[0] = 0`.
2. Для каждой новой позиции `i` копируем длину предыдущей границы `j = pi[i-1]`.
3. Пока `j > 0` и символы `S[i]` и `S[j]` не совпадают, «откатываемся» к более короткой границе `j = pi[j-1]`.
4. Если символы совпали, увеличиваем `j`.
5. Записываем `pi[i] = j`.

Сложность доказуемо `O(|S|)` потому, что `j` уменьшается не чаще, чем увеличивается.

## Применение к поиску подстроки

Чтобы переиспользовать вычисленную функцию, формируем строку

```
S = P + "#" + T
```

Символ `#` выбираем так, чтобы он не встречался ни в шаблоне, ни в тексте, иначе появятся ложные границы. После вычисления `pi` по `S` любое значение `pi[i] == m` (где `m = |P|`) означает, что в тексте завершилось совпадение шаблона. Индекс начала вхождения равен `i - 2m`.

Такой подход позволяет просматривать текст один раз, не возвращаясь назад, что идеально подходит для потокового анализа транскриптов.

## Корректность

1. Каждое значение `pi[i]` не превышает длину шаблона, иначе по определению границы оно было бы длиннее строки.
2. Когда `pi[i] = m`, конец совпадения находится в текстовой части (потому что `#` разрывает шаблон). Значит, мы нашли вхождение `P`.
3. Если `pi[i] < m`, префикс не полный, значит, совпадение ещё не завершено.

## Сложность

- Время: `O(n + m)` — один проход по `S`.
- Память: `O(n + m)` на саму строку и `O(n + m)` на массив `pi`. Дополнительная оперативная память константна.

## Пример

Пусть `P = "ПАСПОРТ ЗАБЛОКИРОВАН"`, `T = "оператор сообщил: ПАСПОРТ ЗАБЛОКИРОВАН повторно"`:

```
S = "ПАСПОРТ ЗАБЛОКИРОВАН#оператор ... повторно"
```

После вычисления `pi` мы получим значение `pi[i] = |P|` ровно в тех точках текста, где фраза повторяется. Это позволяет автоматически построить таймлайн тревожных сигналов, не перечитывая весь текст.

## Встраивание в продуктовую задачу

1. Поток расшифровок поступает строка за строкой.
2. Храним `pi` для `P` и последовательно обновляем значения при конкатенации с очередной строкой (можно делать по батчам).
3. Каждое найденное вхождение транслируем в алерт fraud-аналитикам.

Таким образом, префикс-функция превращает теоретическую конструкцию из статьи Algorithmica в практический инструмент мониторинга качества разговоров.

