# Название

Задача: Оптимальная компоновка модулей в прошивку устройства

# Описание

Условие задачи

Дано встраиваемое устройство с ограниченным объёмом памяти `target` килобайт.
Имеется набор независимых модулей прошивки, размеры которых заданы массивом `nums`.
Необходимо выбрать подмножество модулей так, чтобы их общий размер был максимально
близок к допусти# Problem: Optimal arrangement of modules in the device firmwareмому объёму памяти, но не превышал его. Вернуть суммарный размер выбранных модулей.
Если существует несколько подмножеств с одинаковой близостью к цели, вернуть наибольшую сумму.
(В качестве входных данных могут быть только положительные числа — размеры модулей)

**Входные данные:**

* Первое число n — количество доступных модулей
* Массив `nums` из `n` элементов (1 ≤ n ≤ 40, nums[i] > 0)
* Максимально допустимый объём памяти `target` (0 ≤ target ≤ 10^9)

**Выходные данные:**

* Одно число — суммарный размер подмножества модулей, максимально близкий к `target`, не превышающий его.

**Пример:**

Вход:

n = 5, nums = [200, 300, 700, 800, 1000], target = 1400

Выход:

1300

Объяснение: Подмножество `[300, 1000]` или `[200, 300, 800]` даёт сумму 1300.


# Краткая теория

Теория: Метод meet-in-the-middle для задачи подмножества суммы

## Проблема перебора

Мощность множества всех подмножеств составляет $2^n$, что делает полный перебор неэффективным уже при $n > 40$.

---

## Идея метода meet-in-the-middle

Разбиваем исходное множество на две части:
$$
A = \{a_1,\ldots,a_k\}, \quad B = \{a_{k+1},\ldots,a_n\}
$$
где обычно $k = \lfloor n/2 \rfloor$.

Для каждой части независимо вычисляем множества всех возможных сумм:
$$
S_A = \left\{ \sum_{i\in I} a_i \mid I \subseteq A \right\}, \quad
S_B = \left\{ \sum_{j\in J} a_j \mid J \subseteq B \right\}
$$

Каждое множество содержит примерно $2^{n/2}$ элементов.

---

## Поиск оптимального решения

Для каждого $x \in S_A$ ищем максимальное $y \in S_B$ такое, что:
$$
x + y \le T
$$

После сортировки $S_B$ поиск выполняется двоичным поиском за $O(\log |S_B|)$.

---

## Сложность

- Генерация сумм: $O(2^{n/2})$
- Поиск пар: $O(2^{n/2} \log 2^{n/2}) = O(n \cdot 2^{n/2})$

Итоговая сложность: $O(n \cdot 2^{n/2})$, что значительно лучше $O(2^n)$.


