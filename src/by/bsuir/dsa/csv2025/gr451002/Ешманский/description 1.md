# Название

Основные операции над неявным декартовым деревом

# Описание

Основные операции над неявным декартовым деревом

## Описание

Реализовать структуру данных на основе **декартового дерева (Treap)**, которая хранит массив целых чисел и поддерживает эффективные модификации:

### Поддерживаемые операции:

- `INSERT pos value` — вставка элемента `value` на позицию `pos` (индексация с 0)
- `DELETE pos` — удаление элемента на позиции `pos`
- `UPDATE pos value` — обновление элемента на позиции `pos`
- `GET pos` — получение элемента на позиции `pos`

**Требования:**  
Все операции должны выполняться за O(log n) в среднем.

### Входные данные:


1. **Первая строка:** целое число `N` — начальный размер массива
   `1 ≤ N ≤ 2·10⁵`

2. **Вторая строка:** `N` целых чисел `a_i` — элементы начального массива
   `|a_i| ≤ 10⁹`

3. **Третья строка:** целое число `Q` — количество запросов
   `1 ≤ Q ≤ 2·10⁵`

4. **Следующие Q строк:** каждая строка содержит один запрос в одном из следующих форматов:

  * `INSERT pos value` — вставить `value` на позицию `pos`
  * `DELETE pos` — удалить элемент на позиции `pos`
  * `UPDATE pos value` — заменить элемент на позиции `pos` на `value`
  * `GET pos` — вывести значение элемента на позиции `pos`

> **Примечание:** позиции нумеруются с **0**. Каждый запрос `GET` должен выводить результат на отдельной строке.


### Выходные данные:

- Для каждой операции `GET pos` вывести значение элемента на позиции `pos`.


# Краткая теория

Неявное декартово дерево — структура данных, реализованная на основе **Treap**, которая хранит массив и позволяет эффективно работать с элементами по их позиции (индексу).

В отличие от обычного Treap, здесь **ключи не хранятся явно** — их роль выполняет **позиция элемента в массиве**. Для этого в каждом узле хранится:

* `value` — значение элемента
* `priority` — случайный приоритет (для сохранения heap-свойства)
* `size` — размер поддерева
* ссылки на левое и правое поддерево (`left`, `right`)

Индекс элемента в последовательности вычисляется через `size(left)`.

---

## Основные операции

### Split

Разделяет дерево на два поддерева по позиции `k`:

* `L` — все элементы с индексами `< k`
* `R` — все элементы с индексами `≥ k`

Рекурсивно идём в левое или правое поддерево, корректируя размеры поддеревьев.

**Пример:**
Массив `[10, 20, 30, 40]`, делим по `k = 2`:

* `L = [10, 20]`
* `R = [30, 40]`

---

### Merge

Объединяет два дерева `L` и `R`, где все элементы `L` идут перед элементами `R`.
Корнем становится узел с большим приоритетом, остальные рекурсивно распределяются в левое и правое поддерево.

---

### Вставка (INSERT)

Вставка значения `val` на позицию `index`:

1. Split по позиции `index` → `(L, R)`
2. Создать новый узел `t` с `val` и случайным приоритетом
3. Merge обратно:
   $$
   \text{root} = \operatorname{merge}(L, \operatorname{merge}(t, R))
   $$

Пример: вставка `25` в массив `[10, 20, 30, 40]` на позицию `2` → `[10, 20, 25, 30, 40]`

---

### Удаление (DELETE)

Удаление элемента на позиции `index`:

1. Split по позиции `index` → `(L, midR)`
2. Split `midR` на 1 элемент → `(mid, R)`
3. Merge обратно:
   $$
   \text{root} = \operatorname{merge}(L, R)
   $$

---

### Обновление (UPDATE)

Обновляем значение на позиции `index`:

1. Split по `index` → `(L, midR)`
2. Split `midR` на 1 элемент → `(mid, R)`
3. Создать новый узел с новым значением
4. Merge обратно:
   $$
   \text{root} = \operatorname{merge}(L, \operatorname{merge(mid, R)})
   $$

---

### Получение элемента (GET)

Чтобы получить значение на позиции `index`:

* Если `index < size(left)` → идём в левое поддерево
* Если `index == size(left)` → возвращаем текущее значение
* Иначе → идём в правое поддерево с `index - size(left) - 1`

---

## Расширения

Неявный Treap легко расширять:

* хранение сумм, минимумов, максимумов диапазонов
* персистентная версия для сохранения истории изменений
* работа с динамическими массивами и последовательностями

---

Implicit Treap — это гибкая структура для работы с массивами:

* все базовые операции (`INSERT`, `DELETE`, `UPDATE`, `GET`) выполняются за (O(log n)) в среднем

* позволяет создавать динамические массивы и последовательности с эффективными модификациями


