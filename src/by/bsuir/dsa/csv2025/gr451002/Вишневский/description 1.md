# Название

К-Ним (Мура)

# Описание



# Условие задачи: Реализация игры K-Ним (по теореме Мура)



Реализуйте программу, определяющую, является ли позиция игры _Moore's K-Nim_ выигрышной при нормальной игре (то есть тот, кто делает последний ход — выигрывает).





##  Описание игры K-Ним



Дана игра, состоящая из нескольких куч камней.  

За один ход игрок может **выбрать не более `k` куч** и **уменьшить каждую выбранную кучу на любое положительное число камней**.



Пусть:



-   `piles[i]` — размер i-й кучи (целые неотрицательные числа),

&nbsp;   

-   `k ≥ 1` — максимальное количество куч, которые можно уменьшить за один ход.



Игроки ходят по очереди.  

Проигрывает тот, кто не может сделать ход.



----------



## Теорема Мура (характеризация выигрышных позиций)



Позиция является **проигрышной (P-position)** тогда и только тогда, когда для каждого разряда двоичной записи выполняется:



```

число куч, у которых в этом бите стоит 1  ≡  0 (mod k+1)

```



Если хотя бы для одного бита это условие нарушается, позиция является **выигрышной (N-position)**.





##  Требуется реализовать



### Функция:



```java

boolean isWinningKnim(int[] piles, int k)

```



которая возвращает:



-   `true`, если позиция выигрышная (N-position),

&nbsp;   

-   `false`, если проигрышная (P-position).


### Требования к реализации:



1.  Пустая позиция считается проигрышной.



2.  `k` должен быть ≥ 1.



3. Количества `piles` должны быть положительные.









# Краткая теория


# Игра «Ним»

Рассмотрим следующую игру. Даны  `n`  кучек, в каждой из них какое-то количество камней. За один ход игрок может выбрать кучку и выбросить оттуда любое ненулевое число камней. Выигрывает тот игрок, который забрал последний камень.

**Теорема.**  Состояние игры выигрышное тогда и только тогда, когда xor-сумма размеров кучек отлична от нуля:
```
	S=a1⊕a2⊕…⊕an≠0S=a1​⊕a2​⊕…⊕an=0
```
**Доказательство**  проведём по индукции.

*Для терминального состояния* кучек уже нет, и xor-сумма равна нулю, и оно действительно проигрышное. База доказана — теперь докажем переходы.

Из состояния с нулевой xor-суммой все переходы ведут в выигрышные состояния, то есть в состояния с ненулевой суммой. В самом деле, достаточно убрать сколько угодно спичек из любой кучки — xor-сумма изменится с нуля на  `ai⊕bi`, где  `bi<ai` равно числу камней в  `i`-й кучке после нашего действия.

*Противоположный случай сложнее.* Нужно показать, что если xor-сумма ненулевая, то всегда существует такой  bi<aibi​<ai​, что xor-сумма станет нулевой, то есть


```
		S⊕ai⊕bi=0S⊕ai​⊕bi​=0
```


Для этого посмотрим на старший единичный бит  `S`  и возьмём любой  `ai`​, у которого этот бит тоже единичный. Такой  `ai​`  найдётся хотя бы один — по свойствам  `xor`, их должно быть нечетное число. Из условия выше следует, что искомый  `bi`​  должен быть равен  `S⊕ai`.



Выясняется, что это корректный новый размер кучки, то есть  `bi<ai`​. Почему так? Потому что все старшие биты в выражении остались нетронутыми,  `k`-й бит изменился на единицу, а что происходило с дальнейшими битами нам не важно, потому что эти изменения точно не больше, чем  `2k`.



Получается, что оптимальная стратегия такая: посчитать`xor`-сумму всех  `ai`​, найти такой  `ai`​, у которого старший бит взведен, и заменить его на  `S⊕ai`. (А если xor-сумма  `S` оказалась нулевая, то сдаться.)



## Ним Мура (k-ним)


**Условие.**  Есть  `n`  кучек камней размера  `ai​`. Также задано натуральное число  `k`. За один ход игрок может уменьшить размеры от одной до `k`  кучек (то есть теперь разрешаются одновременные ходы в нескольких кучках сразу). Проигрывает тот, кто не может сделать хода.

Очевидно, при  `k=1`  ним Мура превращается в обычный ним.

**Решение.**  Запишем размер каждой кучки в двоичной системе счисления. Затем просуммируем эти нули и единицы вдоль каждого разряда и возьмём эту сумму по модулю ` (k+1)`. Если во всех разрядах получился ноль, то текущая позиция проигрышная, иначе — выигрышная.

**Доказательство**, как и для обычного нима, заключается в описании стратегии игроков — нужно показать, что

1.  из игры с нулевым значением мы можем перейти только в игры с ненулевыми значениями, и

2.  из любой игры с ненулевым значением найдется ход в игру с нулевым значением.

Первый пункт доказывается следующим рассуждением. Если для всех разрядов сумма бит по модулю  `(k+1)`  была равна нулю, то после изменения от одного до  `k`  элементов снова получить нулевую сумму можно только «уравновешиванием» всех изменений: для всех элементов, где определенный бит удаляется, должен быть другой элемент, где этот бит добавляется. В частности, это должно выполняться и для самого старшего разряда, для которого хотя бы один бит у любого числа меняется. Но тогда это будет означать, что существует какой-то элемент, для которого добавилась единица в этом разряде, а все более старших разрядах ничего не менялось — значит, этот элемент будет больше исходного, что нарушает правила.

Осталось научиться переходить из состояний с ненулевыми суммами в нулевые. Назовём  _проблемными_  те позиции, для которых сумма битов получилась ненулевой. Переберем все биты от старшего к младшему и будем по очереди делать каждую проблемную сумму нулевой, уменьшая какое-то количество элементов.

Обозначим за  `u`  количество кучек, которые мы уже начали изменять; изначально,  `u=0`. Обратим внимание, что так в этих  `u`  кучках мы уменьшали какой-то из предыдущих, более старших, битов, то все более младшие биты мы можем ставить как угодно.

Пусть мы рассматриваем текущий бит, в котором сумма по модулю  `(k+1)`получилась ненулевой. В идеале, мы хотим сделать её нулевой, изменяя в этом разряде только те  `u`  элементов, которые мы и так уже собрались изменять. Мысленно поставим во всех из этих  `u`  элементов единицы в соответствующем разряде и пересчитаем сумму, обозначив её за  `s`. Теперь рассмотрим два случая:

-   Если  `s≤u`, то мы можем обойтись уже выбранными элементами, убрав в `s ` из них единичный бит.

-   В противном случае, если  `s>u`  найдем  `(s−u)`  дополнительных кучек, у которых рассматриваемый бит единичный, и будем уменьшать их вместе с  `u ` уже имеющимися.

После каждой итерации число  `u`  изменяемых кучек станет равным  
```
		u’=max(s,u)≤k
```
Таким образом, мы показали способ выбирать множество изменяемых кучек и какие биты следует в них изменять, чтобы общее их количество  `u`  никогда не превысило  `k`. Следовательно, мы доказали, что искомый переход из состояния с ненулевой суммой в состояние с нулевой суммой всегда существует, что и требовалось доказать.















