# Название

Префикс-функция

# Описание

```markdown
# Минимальный период строки

**Дано:**  
Строка `s`, состоящая из строчных латинских букв  
Длина строки: `1 ≤ |s| ≤ 10^6`

**Необходимо:**  
Найти длину минимального периода строки `s`.  

Период строки — такая строка `t`, что `s` может быть представлена как конкатенация одной или нескольких копий `t`.

**Примеры:**
- `"abcabcabc"` имеет период `"abc"` длиной `3`
- `"aaaa"` имеет период `"a"` длиной `1`
- `"abcde"` имеет период `"abcde"` длиной `5`

---

**Sample Input:**  
```
abcabcabc
```

**Sample Output:**  
```
3
```

# Краткая теория

Префикс-функция

## Определение

**Префикс-функция** строки $s$ длины $n$ — это массив $\pi[0 \dots n-1]$, где $\pi[i]$ определяется как длина наибольшего собственного суффикса подстроки $s[0 \dots i]$, который одновременно является её префиксом.

Формально:
$$
\pi[i] = \max_{0 \leq k \leq i} \{k : s[0 \dots k-1] = s[i-k+1 \dots i]\}
$$

**Собственный суффикс** означает, что $k < i+1$ (суффикс не совпадает со всей строкой).

## Пример

Для строки $s = "abcabcd"$:
- $\pi[0] = 0$ (для "a")
- $\pi[1] = 0$ (для "ab")
- $\pi[2] = 0$ (для "abc") 
- $\pi[3] = 1$ (для "abca" → суффикс "a" = префикс "a")
- $\pi[4] = 2$ (для "abcab" → суффикс "ab" = префикс "ab")
- $\pi[5] = 3$ (для "abcabc" → суффикс "abc" = префикс "abc")
- $\pi[6] = 0$ (для "abcabcd")

## Алгоритм вычисления

```java
public static int[] computePrefixFunction(String s) {
    int n = s.length();
    int[] pi = new int[n];
    for (int i = 1; i < n; i++) {
        int j = pi[i - 1];
        while (j > 0 && s.charAt(i) != s.charAt(j)) {
            j = pi[j - 1];
        }
        if (s.charAt(i) == s.charAt(j)) {
            j++;
        }
        pi[i] = j;
    }
    return pi;
}
```

**Сложность**: $O(n)$, несмотря на вложенный цикл while — амортизированный анализ показывает, что общее число итераций while есть $O(n)$.

## Свойства

### Связь с периодом строки

Строка $s$ имеет **период** длины $p$, если:
$$
s[i] = s[i + p] \quad \text{для всех } i = 0 \dots n-p-1
$$

**Теорема**: Пусть $len = n - \pi[n-1]$. Тогда:
- Если $n$ делится на $len$, то $len$ — минимальный период строки
- Иначе строка не имеет периода (кроме самой себя)

**Пример**: $s = "abcabcabc"$, $n=9$, $\pi[8]=6$, $len=9-6=3$, $9\%3=0$ → период длины 3.

### Другие свойства

1. $\pi[i] < \pi[i+1] \leq \pi[i] + 1$
2. $\pi[i]$ — длина наибольшего бордера (и префикса, и суффикса) для $s[0 \dots i]$
3. Все значения $\pi[i]$ определяются через предыдущие значения префикс-функции

## Применения

### 1. Алгоритм Кнута-Морриса-Пратта
Поиск всех вхождений подстроки за $O(n + m)$.

### 2. Поиск периода строки
Как в нашей задаче — за $O(n)$.

### 3. Сжатие строки
Можно представить строку как несколько повторений своей минимальной периода.

### 4. Подсчёт числа различных подстрок
С помощью префикс-функции можно за $O(n^2)$ найти число различных подстрок.

### 5. Разбиение строки на непересекающиеся вхождения
Найти, на сколько минимальных одинаковых кусков можно разбить строку.

## Практические замечания

### Эффективная реализация

```java
    public static int[] prefixFunction(String s) {
    int n = s.length();
    int[] pi = new int[n];
    for (int i = 1; i < n; i++) {
        int j = pi[i - 1];
        while (j > 0 && s.charAt(i) != s.charAt(j)) {
            j = pi[j - 1];
        }
        if (s.charAt(i) == s.charAt(j)) {
            j++;
        }
        pi[i] = j;
    }
    return pi;
}
```

### Поиск минимального периода

```java
    public static int findMinimalPeriod(String s) {
    int n = s.length();
    int[] pi = computePrefixFunction(s);
    int candidate = n - pi[n - 1];
    return (n % candidate == 0) ? candidate : n;
}
```

