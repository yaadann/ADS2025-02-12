# Название

Алгоритм Дейкстры

# Описание

Алгоритм Дейкстры 
Дан граф, вершины которого отражают места на карте, а ребра - расстояние между ними. 
Изначально вы находитесь в нулевой вершине графа. Найти кратчайшие маршруты из начальной 
точки до всех вершин используя алгоритм Дейкстры.

Граф задан в текстовом файле(консоли) в формате:  
* число вершин графа  
* количество смежных вершин для нулевой вершины  
* смежная вершина;    вес ребра между смежной и нулевой  
* и так далее для других вершин

```
Пример:
    5
    2
    0 2
    4 7
    1
    3 6
    ...
    
    g[0] = { {vertex: 0, edge: 2}, {vertex: 4, edge: 7 } }
    g[1] = { {vertex: 3, edge: 6} }
    ...
    g[4]
```

Нужно реализовать метод `alg()` класса `Main`, который принимает как арумент `InputStream` 
с графом, а возвращает массив строк в виде:  
`res[i] = "path sum: { расстояние кратчайшего маршрута } path: { вершина 0 - ... - вершина i+1}"`  
Маршруты до всех вершин кроме 0 вершины ("path sum: 0 path 0" **НЕ** нужен)

```
    Пример:
       String[] res = { 
          "path sum: 5 path: 0 - 1",
          "path sum: 11 path: 0 - 3 - 2",
          "path sum: 8 path: 0 - 3" };           *для графа из 4 вершин
```

Нумерация вершин в порядке записи в файле начиная с 0.  
Записывать в массив результата в том же порядке.

# Краткая теория

Алгоритм Дейкстры

## Назначение
Поиск кратчайших путей от начальной вершины до всех остальных во взвешенном графе с **неотрицательными весами**.

## Основные понятия
- **Граф** — множество вершин и рёбер между ними
- **Кратчайший маршрут в графе** — это путь между двумя заданными вершинами, который имеет наименьшую суммарную длину (вес)

## Принцип работы

### Инициализация
1. Присвоить начальной вершине расстояние 0
2. Присвоить всем остальным вершинам расстояние ∞
3. Поместить все вершины в непосещённые

### Основной цикл
Пока есть непосещённые вершины:
1. Выбрать вершину с **минимальным расстоянием** из непосещённых
2. Для каждого соседа выбранной вершины:
   - Вычислить новое расстояние = расстояние до текущей вершины + вес ребра
   - Если новое расстояние меньше текущего - обновить
3. Пометить текущую вершину как посещённую  

*Единственное за счет чего можно ускорить алгоритм - более быстрый поиск минимума. Для этого используются такие структуры, как куча или дерево*

## Сложность
- **Реализация через массив**: O(n²)
- **Реализация через двоичное дерево**: O(mlog n)
- **Реализация через кучу**: O(nlog n + m)  

    где n - число вершин, m - число ребер

