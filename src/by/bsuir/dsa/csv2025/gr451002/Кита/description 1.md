# Название

Расстановка скобок в выражении для получения минимального и максимального значения

# Описание

Задание: Расстановка скобок в выражении для получения минимального и максимального значения

## Описание задачи

Разработайте метод `calculateMinMax(String expression)` для нахождения минимального и максимального значения арифметического выражения путем оптимальной расстановки скобок.

## Входные данные

Строка, содержащая арифметическое выражение, состоящее из:
- Цифр (0-9)
- Операторов: `+`, `-`, `*`

Выражение не содержит пробелов или других символов.

## Требования

Используя алгоритм **динамического программирования на подотрезках (Interval DP)**, найдите расстановку скобок, которая дает:
- **Минимальное возможное значение** выражения
- **Максимальное возможное значение** выражения

## Выходные данные

- Минимальное значение выражения и максимальное значение выражения

## Ссылка на алгоритм

Подробное объяснение алгоритма решения можно найти здесь:  
[Справочник Яндекса: Задача расставить скобки](https://education.yandex.ru/handbook/algorithms/article/zadacha-rasstavit-skobki)

## Пример

**Входные данные:**

1+2*3-4*5

**Выходные данные:**
-51 25

# Краткая теория

Теория: Алгоритм расстановки скобок в выражении для получения минимального и максимального значения

## Идея алгоритма

Задача решается методом **динамического программирования**. Основная идея заключается в том, что оптимальное решение для всего выражения можно построить из оптимальных решений для его частей.

## Алгоритм

### Разделение данных:

Арифметическое выражение состоит из чисел и операций {+, -, *}. Длина всей строки, содержащей арифметическое выражение, равна 2k + 1. Тогда в данном выражении k + 1 чисел и k операций.
Необходимо заполнить массив чисел $numbers$ размером k + 1 числами из выражения и массив операторов $operators$ размером k операциями выражения. 

### Создание и инициализация DP-массивов:

Для переведения рекурсивного алгоритма в итерационный используются двумерные массивы, в которых хранятся минимальные и максимальные значения всех подвыражений: minDP[0..n][0..n] и maxDP[0..n][0..n], где n = k + 1 — количество чисел в выражении. Определим:

- $minDP[i][j]$ - минимальное значение подвыражения от $i$ до $j$
- $maxDP[i][j]$ - максимальное значение подвыражения от $i$ до $j$

Базовый случай:
$$
minDP[i][i] = maxDP[i][i] = numbers[i]
$$

Затем инициализируем главную диагональ числами из выражения.

### Заполнение DP для отрезков увеличивающейся длины (len от 2 до количества чисел):
Для каждого начала отрезка i:
j = i + len - 1 (конец отрезка)
Перебрать все возможные точки раздела k от i до j-1, где операция operators[k] будет выполняться последней.

Рекуррентное соотношение для $i < j$:
$$
 Заполняя данные таблицы, нам нужно убедиться, что к окончанию вычислений оптимальных значений для E(i, j) оптимальные значения E(i, k) и E(k+1, j) для всех 
k уже вычислены (E — подвыражение).

Один из способов сделать это — перечислить все пары (i,j) в порядке возрастания значения j −i. 
Для каждого оператора в позиции $k$ вычисляются 4 комбинации:
a = f(minDP[i][k], minDP[k+1][j], operators[k]);
b = f(minDP[i][k], maxDP[k+1][j], operators[k]);
c = f(maxDP[i][k], minDP[k+1][j], operators[k]);
d = f(maxDP[i][k], maxDP[k+1][j], operators[k]);
где $f(x, y, op)$ - применение оператора $op$ к значениям $x$ и $y$
$$

Обновление значений:  
Среди всех комбинаций найти новые minDP[i][j] и maxDP[i][j].
$$
minDP[i][j] = min(minDP[i][j], a, b, c, d);
maxDP[i][j] = max(maxDP[i][j], a, b, c, d);
$$

### Результат: 
Ответ будет находиться в minDP[0][n-1] и maxDP[0][n-1], где n - количество чисел.

