# Название

Адаптивная сортировка посылок

# Описание

Вы работаете в логистической компании, которая занимается срочными доставками. Ваша задача — разработать алгоритм для определения очередности доставки посылок.
Реализуйте класс `DeliveryHandler`, который будет обрабатывать входящие посылки. Класс должен содержать метод `addPackage`, который принимает данные новой посылки, вставляет ее в правильную позицию в отсортированный список, используя принцип сортировки вставками, и возвращает индекс, на который была вставлена посылка.

### Характеристики посылки

Каждая посылка характеризуется:

* `id` (уникальный идентификатор).
* `priority` (приоритет доставки: 1 - наивысший, 5 - низший).
* `distance` (расстояние до точки назначения в километрах).
* `estimatedTime` (расчетное время доставки в минутах).

### Требования к сортировке

Входящий поток посылок не отсортирован. Однако после добавления каждой новой посылки в список, этот список должен поддерживаться отсортированным по следующему комбинированному критерию:

1. **Основной критерий:** `priority` (по возрастанию: 1 идет первым).
2. **Вторичный критерий:** Если приоритет одинаковый, то по `distance` (по возрастанию).
3. **Третичный критерий:** Если и приоритет, и расстояние одинаковы, то по `estimatedTime` (по возрастанию).

Для поддержания порядка в постоянно пополняемом списке идеально подходит алгоритм Сортировки Вставками (Insertion Sort). Ваша задача — реализовать модифицированную версию этого алгоритма.

### Метод

```java
int addPackage(int id, int priority, double distance, int estimatedTime);
```

### Входные параметры

* `id`: Уникальный идентификатор посылки.
* `priority`: Приоритет (1-5).
* `distance`: Расстояние (км).
* `estimatedTime`: Время (мин).

### Возвращаемое значение

* Индекс (считая с 0) в отсортированном списке, на который была вставлена новая посылка.

## Важные требования

* **Не используйте встроенные методы сортировки** (`Collections.sort`, `Arrays.sort` и т.д.) внутри метода `addPackage`. Алгоритм должен самостоятельно находить правильную позицию для вставки и сдвигать элементы, имитируя работу классической сортировки вставками, но для одного нового элемента.
* Изначально список пуст.
* Гарантируется, что `id` уникален для каждого вызова.

## Пример использования

```java
DeliveryHandler handler = new DeliveryHandler();

// Посылка 1: приоритет 2, расстояние 15.5 км, время 30 мин
int index1 = handler.addPackage(1, 2, 15.5, 30);   // Возвращает 0

// Посылка 2: высший приоритет 1 - встает в начало
int index2 = handler.addPackage(2, 1, 10.0, 20);   // Возвращает 0

// Посылка 3: тот же приоритет 2, но меньшее расстояние - встает перед посылкой 1
int index3 = handler.addPackage(3, 2, 5.0, 25);    // Возвращает 1

// Посылка 4: тот же приоритет 2 и расстояние 15.5, но меньшее время - встает перед посылкой 1
int index4 = handler.addPackage(4, 2, 15.5, 25);   // Возвращает 2
```

## Ожидаемый результат

После выполнения примера список должен быть упорядочен следующим образом:

1. Посылка с `id=2`: `priority=1, distance=10.0, time=20`
2. Посылка с `id=3`: `priority=2, distance=5.0, time=25`
3. Посылка с `id=4`: `priority=2, distance=15.5, time=25`
4. Посылка с `id=1`: `priority=2, distance=15.5, time=30`

# Краткая теория

## Сортировка вставками

Сортировка вставками — один из простейших алгоритмов сортировки, который отлично подходит для ситуаций, когда данные поступают постепенно и нужно поддерживать их в отсортированном состоянии.

## Алгоритм работы

Массив условно делится на отсортированную левую часть и неотсортированную правую. Алгоритм последовательно берет каждый элемент из неотсортированной части и вставляет его в правильную позицию в отсортированной части.

**Пошаговое описание:**

1. Начинаем со второго элемента (индекс 1), считая первый элемент уже отсортированным
2. Для текущего элемента:
   - Сохраняем его значение во временную переменную
   - Идем справа налево по отсортированной части
   - Сравниваем текущий элемент с каждым элементом отсортированной части
   - Если текущий элемент МЕНЬШЕ → сдвигаем тот элемент вправо
   - Если текущий элемент БОЛЬШЕ или РАВЕН → останавливаемся
   - Вставляем сохраненный элемент на освободившуюся позицию

**Пример с числами:**

```
Исходный массив: [5, 2, 8, 1, 9]

Шаг 1: [5 | 2, 8, 1, 9]           
       Отсортированная часть: [5]

Шаг 2: [2, 5 | 8, 1, 9]           
       Берем 2, вставляем перед 5
       Отсортированная часть: [2, 5]

Шаг 3: [2, 5, 8 | 1, 9]           
       Берем 8, уже на месте
       Отсортированная часть: [2, 5, 8]

Шаг 4: [1, 2, 5, 8 | 9]           
       Берем 1, вставляем в начало
       Отсортированная часть: [1, 2, 5, 8]

Шаг 5: [1, 2, 5, 8, 9 |]          
       Берем 9, уже на месте
       Результат: [1, 2, 5, 8, 9]
```

## Сложность

- **Лучший случай:** O(n) — когда массив уже отсортирован
- **Худший случай:** O(n²) — когда массив отсортирован в обратном порядке
- **Средний случай:** O(n²)

## Преимущества

- **Адаптивность:** Хорошо работает на частично отсортированных данных
- **Поточная обработка:** Может обрабатывать данные по мере их поступления
- **Стабильность:** Сохраняет относительный порядок равных элементов
- **Простота реализации:** Легко реализовать и понять
- **Эффективность для малых данных:** Быстрее сложных алгоритмов для небольших массивов

## Недостатки

- Неэффективен на больших массивах
- Квадратичная сложность в худшем случае

