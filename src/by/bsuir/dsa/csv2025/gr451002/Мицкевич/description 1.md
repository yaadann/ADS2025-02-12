# Название

Поиск подстроки с помощью Z-функции

# Описание

Поиск подстроки с помощью Z-функции

## Условие задачи

Даны строка **text** и подстрока **pattern**. Необходимо найти все вхождения подстроки **pattern** в строке **text** с помощью алгоритма Z-функции.

**Z-функция** строки `s` — это массив `Z`, где `Z[i]` — это длина наибольшего общего префикса строки `s` и суффикса `s[i..n-1]`, начинающегося с позиции `i`.

**Задача:** Для заданных строк `text` и `pattern` найти все позиции, в которых `pattern` встречается в `text`, используя Z-функцию.

## Требования

1. Изучить теоретические основы Z-функции
2. Доказать корректность алгоритма вычисления Z-функции
3. Разработать алгоритм поиска подстроки с помощью Z-функции
4. Привести примеры работы алгоритма

## Формат решения

- Математическое доказательство корректности алгоритма
- Алгоритм вычисления Z-функции за O(n)
- Алгоритм поиска всех вхождений подстроки за O(n + m)
- Примеры для различных входных данных

---

### Особенности этой задачи:

- **Эффективный алгоритм** - линейная временная сложность O(n + m)
- **Практическое применение** - поиск подстроки в тексте
- **Элегантное решение** - использование Z-функции для эффективного поиска
- **Хороша для изучения** - позволяет понять основы алгоритмов на строках

Эта задача отлично подходит для изучения алгоритмов поиска подстроки и работы со строками.


# Краткая теория

---
author: Мицкевич Никита
weight: 1
---

# Поиск подстроки с помощью Z-функции

## Условие задачи

Даны строка **text** и подстрока **pattern**. Необходимо найти все вхождения подстроки **pattern** в строке **text** с помощью алгоритма Z-функции.

## Теоретический анализ

### Определение Z-функции

**Z-функция** строки `s` длины `n` — это массив `Z[0..n-1]`, где `Z[i]` — это длина наибольшего общего префикса строки `s` и суффикса `s[i..n-1]`, начинающегося с позиции `i`.

**Формальное определение:**
```
Z[i] = max{k : s[0..k-1] = s[i..i+k-1]}
```

**Свойства Z-функции:**
1. `Z[0] = n` (по определению, вся строка совпадает сама с собой)
2. `Z[i] ≤ n - i` для всех `i ∈ [1, n-1]`
3. Если `Z[i] > 0`, то `s[0..Z[i]-1] = s[i..i+Z[i]-1]`

### Примеры Z-функции

**Пример 1:** `s = "aaaa"`
```
Z[0] = 4
Z[1] = 3
Z[2] = 2
Z[3] = 1
```

**Пример 2:** `s = "abacaba"`
```
Z[0] = 7
Z[1] = 0
Z[2] = 1
Z[3] = 0
Z[4] = 3
Z[5] = 0
Z[6] = 1
```

### Алгоритм вычисления Z-функции

**Идея алгоритма:** Используем уже вычисленные значения Z-функции для ускорения вычислений.

**Основная идея:** Поддерживаем интервал `[l, r]` — самый правый Z-блок (интервал, для которого мы уже вычислили Z-функцию и знаем, что `s[0..r-l] = s[l..r]`).

**Алгоритм:**
1. Инициализация: `Z[0] = n`, `l = 0`, `r = 0`
2. Для каждого `i` от 1 до n-1:
   - Если `i ≤ r`, используем уже вычисленное значение: `Z[i] = min(r - i + 1, Z[i - l])`
   - Расширяем Z-блок вправо, пока символы совпадают
   - Обновляем `l` и `r`, если нашли более правый Z-блок

**Псевдокод:**
```
Z[0] = n
l = 0, r = 0
for i = 1 to n-1:
    if i <= r:
        Z[i] = min(r - i + 1, Z[i - l])
    else:
        Z[i] = 0
    
    while i + Z[i] < n and s[Z[i]] == s[i + Z[i]]:
        Z[i]++
    
    if i + Z[i] - 1 > r:
        l = i
        r = i + Z[i] - 1
```

### Доказательство корректности

**Лемма 1.** Если `i ≤ r`, то `Z[i] ≥ min(r - i + 1, Z[i - l])`.

**Доказательство:** 
Поскольку `s[0..r-l] = s[l..r]`, то для позиции `i` в интервале `[l, r]`:
- Если `Z[i - l] < r - i + 1`, то `Z[i] = Z[i - l]`
- Если `Z[i - l] ≥ r - i + 1`, то можем использовать значение `r - i + 1` как начальное приближение

**Теорема.** Алгоритм вычисляет Z-функцию корректно за время O(n).

**Доказательство:**
1. **Корректность:** Следует из леммы 1 и того, что мы расширяем Z-блок только при совпадении символов.
2. **Временная сложность:** Каждый символ строки просматривается не более двух раз (один раз при расширении Z-блока, один раз при обновлении границ), поэтому общая сложность O(n).

### Применение Z-функции для поиска подстроки

**Задача:** Найти все вхождения подстроки `pattern` в тексте `text`.

**Идея:** Создадим строку `s = pattern + '$' + text`, где `'$'` — символ, не встречающийся ни в `pattern`, ни в `text`. Вычислим Z-функцию для `s`. Тогда все позиции `i`, для которых `Z[i] = |pattern|`, соответствуют вхождениям `pattern` в `text`.

**Алгоритм:**
1. Создать строку `combined = pattern + '$' + text`
2. Вычислить Z-функцию для `combined`
3. Найти все позиции `i`, где `i > |pattern|` и `Z[i] = |pattern|`
4. Позиция вхождения в исходном тексте: `i - |pattern| - 1`

**Временная сложность:** O(|pattern| + |text|) = O(n + m), где `n = |text|`, `m = |pattern|`.

**Пространственная сложность:** O(n + m).

### Пример работы алгоритма

**Входные данные:**
- `text = "abacaba"`
- `pattern = "aba"`

**Шаг 1:** Создаем `combined = "aba$abacaba"`

**Шаг 2:** Вычисляем Z-функцию:
```
Z[0] = 11
Z[1] = 0
Z[2] = 1
Z[3] = 0
Z[4] = 3  ← вхождение (Z[4] = 3 = |pattern|)
Z[5] = 0
Z[6] = 1
Z[7] = 0
Z[8] = 3  ← вхождение (Z[8] = 3 = |pattern|)
Z[9] = 0
Z[10] = 1
```

**Шаг 3:** Находим вхождения:
- Позиция 4 в `combined` → позиция 0 в `text`
- Позиция 8 в `combined` → позиция 4 в `text`

**Результат:** Вхождения на позициях 0 и 4.

## Сравнение с другими алгоритмами

### Z-функция vs. Префикс-функция (KMP)

- **Z-функция:** `Z[i]` — длина наибольшего общего префикса строки и суффикса, начинающегося с позиции `i`
- **Префикс-функция:** `π[i]` — длина наибольшего собственного суффикса префикса `s[0..i]`, который является префиксом строки

Оба алгоритма имеют сложность O(n), но Z-функция более интуитивна для понимания.

### Z-функция vs. Наивный алгоритм

- **Наивный алгоритм:** O(n·m) в худшем случае
- **Z-функция:** O(n + m) в любом случае

Z-функция значительно эффективнее для больших текстов.

## Обобщения и приложения

### Поиск нескольких подстрок

Z-функция может быть использована для поиска нескольких подстрок одновременно, комбинируя их в одну строку с разделителями.

### Поиск периодических подстрок

Z-функция позволяет эффективно находить периодические подстроки в строке.

### Сжатие строк

Z-функция используется в алгоритмах сжатия строк, таких как LZ77.

## Заключение

Z-функция представляет собой мощный инструмент для работы со строками, позволяющий эффективно решать задачи поиска подстроки за линейное время. Простота реализации и понимания делает её идеальным объектом для изучения алгоритмов на строках.

Полученные результаты имеют практическое значение в обработке текстов, поисковых системах, биоинформатике и других областях, где требуется эффективный поиск подстрок.


