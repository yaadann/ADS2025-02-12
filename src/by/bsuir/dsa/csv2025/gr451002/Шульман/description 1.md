# Название

Простой строковый хеш

# Описание

Простой строковый хеш

Вам дана строка, состоящая из символов: пробел (`' '`), цифры `0–9`, латинские буквы `A–Z` и `a–z`.

Необходимо вычислить **полиномиальный хеш** этой строки по следующей формуле:

\[
h_0 = 0,
\]
\[
h_{i+1} = (h_i \cdot P + \mathrm{code}(s_i)) \bmod M,
\]
\[
\mathrm{hash}(s) = h_n,
\]

где:

- \(P = 131\),
- \(M = 10^9 + 7\),
- \(\mathrm{code}(s_i)\) — ASCII-код символа.

## Формат ввода

Одна строка — строка \(s\).  
Строка может содержать пробелы, но не содержит переводов строки внутри.

## Формат вывода

Выведите одно целое число — \(\mathrm{hash}(s)\).

## Примеры

1.  
Ввод: `abc`  
Вывод: `1677554`

2.  
Ввод: `Hello world`  
Вывод: `21160602`


# Краткая теория

## Краткая теория

### 1. Идея хеширования строк

Хеш-функция переводит объект (например, строку) в целое число — *хеш*.

Цели:

- быстро сравнивать строки (сравнение чисел дешевле, чем посимвольное сравнение);
- хранить ключи в структурах данных (хеш-таблица, set, unordered_map и т.д.).

Важно: хеширование всегда теоретически допускает **коллизии** — разные строки могут иметь одинаковый хеш, но при хорошем выборе параметров вероятность небольшой.

### 2. Полиномиальный хеш

Для строки \(s = s_0 s_1 \dots s_{n-1}\) определим:

\[
h_0 = 0,
\]
\[
h_{i+1} = (h_i \cdot P + \mathrm{code}(s_i)) \bmod M,
\]
\[
\mathrm{hash}(s) = h_n.
\]

Здесь:

- \(P\) — основание (обычно берут небольшое простое или просто "рандомное" число, например \(P = 131\) или \(P = 257\));
- \(M\) — большой модуль (часто \(10^9 + 7\) или \(10^9 + 9\));
- \(\mathrm{code}(s_i)\) — числовое значение символа (например, ASCII-код).

Интуитивно это "число в системе счисления с основанием \(P\)", посчитанное по модулю \(M\).

Итеративная формула удобна для реализации в коде:

```text
h = 0
for each character c in s:
    h = (h * P + code(c)) mod M
return h

