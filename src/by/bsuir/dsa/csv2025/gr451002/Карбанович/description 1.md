# Название

k-й по величине неотрицательный элемент массива

# Описание

Задача: k-й по величине неотрицательный элемент массива

## Условие

Дан массив из `n` целых чисел и число `k`. Найдите **k-й по величине неотрицательный элемент** массива (нумерация с 1).  
Если неотрицательных элементов меньше `k`, выведите `-1`.  

### Входные данные

Первая строка содержит два целых числа:  

1 <= n <= 100000 — количество элементов массива
1 <= k <= n — номер элемента, который нужно найти

Вторая строка содержит `n` целых чисел — элементы массива.  

### Выходные данные

Выведите одно число — k-й по величине неотрицательный элемент массива, или `-1`, если таких элементов меньше k.  

## Примеры

### Пример 1

**Вход:**

5 2
7 -3 10 1 -5

**Выход:**

7

### Пример 2

**Вход:**

6 4
13 1 -9 25 4 -7

**Выход:**

25

# Краткая теория

HeapSort (пирамидальная сортировка)

## Что такое HeapSort  
- HeapSort — это алгоритм сортировки на основе структуры данных **куча** (обычно — двоичная куча, max‑куча). 
- Он похож на сортировку выбором: на каждом шаге выбирается максимум (или минимум), после чего он перемещается в конец (или начало) массива. 
- Алгоритм работает **in-place**, то есть почти не требует дополнительной памяти (служебная память — O(1)).  
- Время работы в худшем, среднем и лучшем случаях — O(n log n).  

## Основные шаги алгоритма

1. **Построение кучи (Build‑Heap)**  
   - Преобразовать входной массив в max-кучу.   
   - Делается с помощью операции `heapify` (или «просеивания вниз» — `sift_down`) начиная с первого не‑листового узла. 
   - Интересно: асимптотически этот процесс занимает O(n), а не O(n log n).  

2. **Сортировка**  
   - После того, как массив стал max-кучей, самый большой элемент — в корне (индекс 0 или 1, в зависимости от реализации).   
   - Меняем корень с последним элементом кучи, уменьшаем «размер» кучи на 1. 
   - Применяем `sift_down` к корню, чтобы восстановить свойство кучи.   
   - Повторяем, пока в куче остаётся больше одного элемента. 
   - В конце (в зависимости от реализации) можно перевернуть массив, если достигнут порядок по убыванию. 

## Свойства

- **Сложность времени**: O(n log n) гарантированно.
- **Дополнительная память**: O(1) (in-place).  
- **Неустойчивость**: HeapSort обычно не является устойчивым алгоритмом, т.е. одинаковые элементы могут менять порядок. 
- **Плюсы**:
  - Гарантированная временная сложность, в отличие от QuickSort, который может деградировать.  
  - Не требует значительного дополнительного пространства. 
- **Минусы**:
  - Иногда медленнее на практике, чем хорошо реализованный QuickSort, из-за плохой локальности доступа к памяти. 
  - Неустойчивость.  

