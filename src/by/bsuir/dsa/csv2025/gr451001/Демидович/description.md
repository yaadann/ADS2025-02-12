# Name

The Reverberating Drum Sequence

# Task

The Reverberating Drum Sequence

## Scenario

You are playing on two drums — the **Left ('L')** and the **Right ('R')** — inside a studio with very strong and fast acoustics. Your performance is being captured by a sensitive microphone.

## Condition

Due to the room's specific **reverberation** effect, every single hit you make on a drum can be registered by the microphone in one of two ways:
1.  **Once:** Only the initial drum hit is clearly heard (e.g., 'L').
2.  **Twice:** The hit and its immediate, strong echo are captured as two quick, identical sounds (e.g., 'LL').

You are provided with two logs:
1.  **$P$ (The Score)** — The exact sequence of hits you performed.
2.  **$S$ (The Recording)** — The actual sequence of sounds the microphone captured.

**Goal:** Determine if the sound sequence $S$ could have resulted from your hit sequence $P$ within this acoustic environment.

# Theory

## Essence of the Problem

The task is to determine if the **sequence of sounds $S$** could have been generated by the **sequence of hits $P$**, given that every single hit $X \in \{\text{'L'}, \text{'R'}\}$ can result in either $X$ or $XX$ due to the room's acoustics.

##  Key Observation

The expansion property $X \to \{X, XX\}$ ensures that the type of drum ('L' or 'R') cannot change during a hit.
1. A **'L'** hit can only produce 'L' or 'LL'.
2. A **'R'** hit can only produce 'R' or 'RR'.

This implies that the **alternating structure** of identical character blocks in $P$ and $S$ must be identical.



---

## Solution Method: Block Analysis (RLE)

To solve the problem, we use **Run-Length Encoding (RLE)** to convert both strings ($P$ and $S$) into sequences of blocks.

### 1. Partitioning into Blocks

Strings $P$ and $S$ are partitioned into maximal groups of contiguous identical characters.
Let $P = P_1 P_2 \ldots P_k$ and $S = S_1 S_2 \ldots S_m$, where $P_i$ and $S_i$ are the blocks.

* **Example:** $P = \text{"LLRLL"}$ partitions into 3 blocks: $P_1 = \text{"LL"}$ (L, 2), $P_2 = \text{"R"}$ (R, 1), $P_3 = \text{"LL"}$ (L, 2).

### 2. Checking Correspondence

The solution requires three sequential checks for the blocks:

**A. Block Count**

The total number of blocks in $P$ must match the total number of blocks in $S$.
$$
k = m
$$
If $k \ne m$, $S$ could not have resulted from $P$, and the answer is **NO**.

**B. Block Type**

For every $i$ from $1$ to $k$, the character type in block $P_i$ must match the character type in block $S_i$.
$$
\text{type}(P_i) = \text{type}(S_i)
$$
If $\text{type}(P_i) \ne \text{type}(S_i)$ (e.g., $P_i$ is 'L' and $S_i$ is 'R'), the answer is **NO**.

**C. Length Range**

The length of each block in $S$ must be a valid **extension** of the corresponding block in $P$. If $P_i$ consists of $L_P$ identical hits, these hits must produce $L_S$ sounds in $S_i$. Since each of the $L_P$ hits could yield $1$ or $2$ sounds:
* Minimum length $L_S$: all hits yield 1 sound $\implies L_S = L_P$.
* Maximum length $L_S$: all hits yield 2 sounds $\implies L_S = 2 L_P$.

Thus, for every block $i$, the following must hold:
$$
|P_i| \le |S_i| \le 2|P_i|
$$
If this inequality is violated for even one block, the answer is **NO**.

If all three conditions (A, B, C) are satisfied for all blocks, the answer is **YES**.

---

## Implementation Notes

The RLE method is efficiently implemented in linear time $O(|P| + |S|)$ by using a **two-pointer** or **iterative pass** approach to condense the strings into block lists.

| Case | P | S | $|P_i|$ | $|S_i|$ | Result |
| :---: | :---: | :---: | :---: | :---: | :---: |
| ✅ Min. Extension | `RR` | `RR` | 2 | 2 | YES ($2 \le 2 \le 4$) |
| ✅ Max. Extension | `R` | `RR` | 1 | 2 | YES ($1 \le 2 \le 2$) |
| ❌ Too Short | `LL` | `L` | 2 | 1 | NO ($1 < 2$) |
| ❌ Too Long | `R` | `RRR` | 1 | 3 | NO ($3 > 2$) |
| ❌ Structure Fail | `LR` | `LRRRL` | $L(1) R(1)$ | $L(1) R(3) L(1)$ | NO (2 blocks $\ne$ 3 blocks) |

