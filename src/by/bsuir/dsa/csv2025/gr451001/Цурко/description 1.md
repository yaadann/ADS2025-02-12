# Название

Лабораторное сворачивание

# Описание

Лабораторное сворачивание

В исследовательской лаборатории изучают длинные цепочки молекул, представленные строкой из символов `A`, `C`, `G`, `T`.  
Каждый символ обозначает один тип молекулы.

Учёные открыли процесс под названием *Folding*, который позволяет укорачивать молекулярные цепочки, сохраняя их ключевые свойства.

---

## Описание процесса Folding

- Выбирается точка разреза между двумя соседними молекулами.
- Левая и правая части должны быть зеркально одинаковыми до ближайшего конца цепочки.
- Если условие выполняется, цепочка «сворачивается» в этой точке, а совпадающие молекулы объединяются.

### Пример
Для цепочки `ATTACC` возможны два разреза:
- `AT | TACC`
- `ATTAC | C`

Если выбрать первый разрез, то после Folding получится новая цепочка `CCAT` или `TACC`.

---

## Задача

Дана молекулярная цепочка `s`, состоящая из символов `A`, `C`, `G`, `T`.  
Нужно определить **минимально возможную длину цепочки**, которую можно получить, применяя Folding ноль или более раз.

---

## Входные данные
Одна строка `s` (1 ≤ |s| ≤ 4·10^6), где |s| — длина цепочки.

---

## Выходные данные
Одно число — минимальная длина цепочки после оптимального применения операций Folding.

---

# Краткая теория

---
title: Алгоритм Манакера (с пояснениями)
weight: 5
authors:
- Vlad Tsurko
created: 2025
---

## Введение

Во многих задачах на строки требуется находить **палиндромы**.  
**Палиндром** — это строка, которая читается одинаково слева направо и справа налево.  
Примеры: `abba`, `racecar`, `топот`.

Наивный алгоритм проверяет каждую подстроку (то есть любую часть строки) и работает за $O(n^2)$, где $n$ — длина строки.  
**Асимптотика $O(n^2)$** означает, что время работы растёт пропорционально квадрату длины строки. Для строки длиной миллион символов это слишком долго.

**Алгоритм Манакера** решает проблему: он находит все палиндромные подстроки за $O(n)$, то есть линейное время.  
**Линейное время $O(n)$** — это значит, что количество операций растёт прямо пропорционально длине строки.

---

## Основная идея

1. Рассмотрим строку `s` длины $n`.  
2. Для каждой позиции $i$ мы хотим знать максимальный **радиус палиндрома**.  
   - **Радиус палиндрома** — это число символов, на которое палиндром можно расширить влево и вправо от центра.  
   - Например, в строке `abba` центр в букве `b` имеет радиус 2, потому что можно расшириться на 2 символа влево и вправо и получить палиндром `abba`.
3. Если мы уже знаем самый правый палиндром $[L, R]$, то для новой позиции $i$ внутри этого диапазона можно использовать **зеркальную позицию** $j = L + R - i$.  
   - **Зеркальная позиция** — это симметричная точка относительно центра палиндрома.  
   - Радиус палиндрома в $i$ будет как минимум равен радиусу в $j$, но ограничен правой границей $R$.
4. После этого мы пытаемся расширить палиндром вокруг $i$, пока символы совпадают.  
5. Если новый палиндром выходит за $R$, обновляем $L$ и $R`.  
   - $L$ и $R$ — это левая и правая границы самого правого найденного палиндрома.

---

## Технические детали

Чтобы обрабатывать **чётные** и **нечётные** палиндромы одинаково, строку преобразуют:  
- Между символами вставляют **разделитель**, например `#`.  
- Пример: строка `abba` превращается в `#a#b#b#a#`.  
- Теперь все палиндромы имеют нечётную длину, и алгоритм работает единообразно.

---

## Псевдокод

**Псевдокод** — это упрощённая запись алгоритма, близкая к коду, но не зависящая от конкретного языка программирования.

```cpp
vector<int> manacher(string s) {
    int n = s.size();
    vector<int> d(n); // радиусы палиндромов
    int L = 0, R = -1;
    for (int i = 0; i < n; i++) {
        int k = (i > R) ? 1 : min(d[L + R - i], R - i + 1);
        while (i - k >= 0 && i + k < n && s[i - k] == s[i + k]) k++;
        d[i] = k;
        if (i + k - 1 > R) {
            L = i - k + 1;
            R = i + k - 1;
        }
    }
    return d;
}

