# Название

Загрузка судна на два борта

# Описание

Загрузка судна на два борта

## Описание
На судне есть два борта: левый и правый. Для безопасности на судне при загрузке действуют ограничения:
- масса на левом борту не должна превышать WL,
- масса на правом борту не должна превышать WR,
- разница масс между бортами не должна превышать B.

Даны n грузов с целочисленными массами w[i]. Каждый груз можно:
- поставить на левый борт,
- поставить на правый борт,
- или не брать.

Цель — максимизировать суммарную массу загруженных грузов при соблюдении всех ограничений.

## Ввод
Первая строка содержит четыре целых числа: WL (максимально допустимая масса на левом борту), WR (максимально допустимая масса на правом борту), B (максимально допустимая разница масс между левым и правым бортами), n (число грузов). Вторая строка содержит n целых чисел w[i] (масса i-го груза).

## Вывод
Выведите одно число — максимальную суммарную массу грузов на судне (L + R) при выполнении условий:
- L ≤ WL,
- R ≤ WR,
- |L − R| ≤ B,

где L и R — суммарные массы на левом и правом борту соответственно.

Если подходит только пустая загрузка, выведите 0.

## Примечания
Все входные значения — целые числа. Диапазоны:
0 ≤ WL, WR ≤ 1000,
0 ≤ B ≤ 1000,
1 ≤ n ≤ 1000,
1 ≤ w[i] ≤ 1000


# Краткая теория

Динамическое программирование

## Введение
Динамическое программирование (ДП) — метод оптимизации, в котором сложная задача разбивается на перекрывающиеся подзадачи, а их решения сохраняются и переиспользуются. Ключевая идея: построить рекуррентную формулу и заполнять таблицу значений, избегая повторных вычислений.

## Основная идея
- Разложение задачи на подзадачи, имеющие оптимальную подструктуру.
- Хранение результатов для избежания экспоненциального перебора.
- Выбор порядка вычисления: снизу вверх (итеративно) или сверху вниз (мемоизация).

## Формулировка рекуррентных соотношений
- Обозначьте состояние, которое полностью описывает подзадачу.
- Запишите переходы между состояниями.
- Определите базовые случаи.

Например, для классического ДП:
- Состояние: f[i] — оптимальный ответ на префиксе из i элементов.
- Переход: f[i] = min/max по допустимым действиям от f[j], где j < i.
- База: f[0] = 0 (или другая нейтральная константа).

## Подходы к реализации

### Сверху вниз (мемоизация)
```
def solve(state):
  if memo[state] exists: return memo[state]
  if base(state): return base_value
  ans = combine( solve(next_state_1), solve(next_state_2), ... )
  memo[state] = ans
  return ans
```
- Плюсы: пишется близко к математической рекурсии; считает только нужные состояния.
- Минусы: контроль глубины стека, сложнее гарантировать порядок и инварианты.

### Снизу вверх (итеративно)
```
init dp[...] = INF or neutral
dp[base_state] = base_value
for states in topological_order:
  for transition in outgoing:
    dp[next] = best(dp[next], combine(dp[current], cost))
```
- Плюсы: стабильное потребление памяти, отсутствие рекурсивных вызовов.
- Минусы: нужно заранее определить корректный порядок обхода состояний.

## Практические рекомендации
- Начинайте с определения состояния, затем баз и переходов.
- Проверяйте граничные случаи на пустых или минимальных данных.
- Профилируйте память, особенно для двумерных ДП.
- Сначала делайте рабочую O(n^2) версию, затем оптимизируйте.

## Задача рюкзака

### Формулировка
- Дано n предметов с весами w_i и стоимостями v_i, есть вместимость W.
- Нужно максимизировать суммарную стоимость, чтобы сумма весов не превышала W.

### 0/1 рюкзак (каждый предмет либо берется полностью, либо нет)
- Классическое ДП:
```
dp[i][w] = максимальная стоимость, используя первые i предметов при вместимости w
dp[0][w] = 0
dp[i][w] = max( dp[i-1][w], dp[i-1][w - w_i] + v_i )  if w_i ≤ w
dp[i][w] = dp[i-1][w]                                 otherwise
```
- Сжатие памяти до O(W):
```
dp[w] = 0
for i in 1..n:
  for w from W down to w_i:
    dp[w] = max(dp[w], dp[w - w_i] + v_i)
```
- Сложность: O(nW) времени, O(W) памяти.

### Дробный рюкзак (можно брать доли предмета)
- Решается жадно: сортировка по удельной стоимости v_i / w_i и набираем до заполнения W.
- Важно: жадный подход неприменим к 0/1 рюкзаку.

## Итоги
ДП позволяет формально описать состояние и переходы, а затем системно вычислить оптимальные ответы. Для рюкзака 0/1 — базовое ДП с сжатием памяти, для дробного — жадное решение.

