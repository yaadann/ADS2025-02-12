# Название

Спасение в глубоком лабиринте

# Описание

Спасение в глубоком лабиринте
## Описание задачи
Имеется сеть туннелей, представленных графом с n вершинами и m рёбрами. Вершины пронумерованы от 1 до n. По туннелям разрешено передвигаться только в одном направлении. Курьер стартует из вершины s и должен добраться до целевой вершины t. Курьер исследует туннели «вглубь», пока не упирается в тупик, затем откатывается назад. Если вершина t достижима, необходимо вывести путь от s до t, в противном случае нужно вывести NO PATH. Также нужно вывести порядок посещения вершин.
## Формат ввода
```
n m
u1 v1
u2 v2
...
um vm
s t
```
Каждая пара `ui vi` — ориентированное ребро из `ui` в `vi`.
## Формат вывода
```
path: p1 p2 ... pk
order: a1 a2 ... ar
```
Где `path` — последовательность вершин от s до t, или NO PATH. `order` — порядок посещений всех вершин, достигнутых из s. Соседей следует посещать в порядке возрастания их номеров.
## Пример
Ввод:
```
6 6
1 2
1 3
2 4
3 5
5 4
4 6
1 6
```
Вывод:
```
order 1 2 4 6 3 5
path 1 2 4 6
```

# Краткая теория

Поиск в глубину
Поиск в Глубину (Depth-First Search, DFS) — это алгоритм обхода или поиска в графовых или древовидных структурах данных. Его стратегия состоит в том, чтобы исследовать как можно глубже вдоль каждой ветви, прежде чем выполнить возврат (backtracking) и начать исследовать другие ветви.
## Основные принципы
1. Стратегия "Вглубь": Алгоритм начинает с выбранной начальной вершины и идет максимально далеко по одному из путей.
2. Используемая Структура Данных: DFS естественным образом реализуется с помощью стека (Stack) для хранения вершин, которые нужно посетить, или с помощью рекурсии (которая неявно использует стек вызовов).
3. Посещенные Вершины: Для предотвращения бесконечных циклов в графах (особенно в тех, что содержат циклы) и повторного обхода, необходимо хранить список или набор посещенных вершин (например, используя `Set<Integer>` или массив `boolean[]`).
## Алгоритм
Рекурсивная реализация является наиболее распространенной и элегантной.
1. Начало: Выбрать стартовую вершину v.
2. Пометка: Пометить v как посещенную.
3. Обработка: Выполнить необходимые действия с вершиной v (например, вывести ее на печать).
4. Рекурсивный Вызов: Для каждой непосещенной смежной вершины w (сосед v) рекурсивно вызвать DFS для w.

Пример для языка Java:
```java
public void DFS(int v) {
    visited[v] = true;
    for (int neighbor : adj.get(v)) {
        if (!visited[neighbor]) {
            DFS(neighbor);
        }
    }
}
```

