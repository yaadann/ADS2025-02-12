# Название

Рейтинг игроков

# Описание

Рейтинг игроков

## Описание Задачи
В онлайн-игре есть система рейтинга игроков. Каждый игрок имеет:
Вы разрабатываете ядро системы управления рейтингами игроков в онлайн игре. У каждого игрока есть свой уникальный **id**. У каждого из игроков должен быть неотрицательный **rating**.

Вы должны написать программу, которая будет эффективно отвечать на следующие запросы:
  **1. addPlayer(id, rating)** - добавление игрока, с переданными в запросе **id**, и **rating**. Если игрок с таким **id** уже существует, **rating** обновляется.
  **2. removePlayer(id)** - удаление игрока с **id** переданным в запросе.
  **3. updateRating(id, newRating)** - обновление рейтинга игрока с **id** переданным в запросе, на **newRating**.
  **4. kthPlayer(k)** - возвращает **id** игрока(ов) проверить, чей рейтинг занимает **k**-ое место в топе.
  **5. countPlayersInRange(L, R)** - возвращает количество игроков с рейтингом в диапазоне **[L, R]**, включая **L** и **R**.

---

## Входные данные

В первой строке находится число **Q** - количество запросов. **(Q <= $1*10^5$)**
Следующие **Q** строк содержат запросы в следующем формате:
  **1 id rating** - запрос **addPlayer**. **(0 <= id <= $5*10^4$; 0 <= rating <= $1*10^4$)**
  **2 id** - запрос **removePlayer**.
  **3 id newRating** - запрос **updateRating**.
  **4 k** - запрос **kthPlayer**. **(1 <= k <= $5*10^4$)**
  **5 L R** - запрос **countPlayersInRange**. **(0 <= L < R <= $1*10^4$)**
При вводе запросов с невалидными данными - игнорировать, например, если если введен **id** несуществующего игрока.

---

## Выходные данные

На запросы четвертого типа программа должна вывести **id** игрока, если игроков удовлетворяющих условию несколько выводить их **id** через пробел.
На запросы пятого типа программы должна вывести единственное число - количество игроков с **rating** в диапазоне **[L, R]**.

---

## Пример

**Входные данные**
8
1 1 1500
1 2 1700
1 3 1200
4 2
3 3 1500
4 2
5 1400 1600
2 2
4 1

**Выходные данные**
1
1 3
2
1 3

# Краткая теория

AVL-деревья

AVL-дерево — это **самобалансирующееся бинарное дерево поиска (BST)**, в котором для каждого узла выполнено условие:

$$
|height(left) - height(right)| \le 1
$$

где \(height(v)\) — высота поддерева узла \(v\).

---

## ## Свойства AVL-деревьев

1. **Бинарное дерево поиска:**

Для любого узла со значением \(k\):

- все значения в левом поддереве меньше:  
  $$
  \forall x \in left,\; x < k
  $$
- все значения в правом поддереве больше:  
  $$
  \forall x \in right,\; x > k
  $$

2. **Строгое балансирование:**  
   Разница высот поддеревьев никогда не превышает 1.

3. **Высота дерева:**

$$
h = O(\log n)
$$

4. **Скорости операций:**

| Операция        | Сложность |
|-----------------|-----------|
| Поиск           | \(O(\log n)\) |
| Вставка         | \(O(\log n)\) |
| Удаление        | \(O(\log n)\) |

---

## ## Баланс-фактор

Определён как:

$$
bf(v) = height(v_{left}) - height(v_{right})
$$

Узлы, где \(bf = \pm 2\), вызывают дисбаланс.

---

## ## Балансировки (повороты)

### 1. Малый правый поворот (LL-случай)

Если:

$$
bf(v) = 2,\quad bf(v_{left}) \ge 0
$$

→ выполняется правый поворот.

### 2. Малый левый поворот (RR-случай)

Если:

$$
bf(v) = -2,\quad bf(v_{right}) \le 0
$$

→ выполняется левый поворот.

### 3. Большой левый (LR) и большой правый (RL) повороты

Используются, когда:

$$
bf(v) = 2,\ bf(v_{left}) < 0 \quad\text{(LR)}
$$

или

$$
bf(v) = -2,\ bf(v_{right}) > 0 \quad\text{(RL)}
$$

---

# Хеш-таблицы

Хеш-таблица — структура данных, обеспечивающая доступ к элементу по ключу за **амортизированное время \(O(1)\)**.

---

## ## Хеш-функция

Отображает ключ \(k\) в индекс массива:

$$
index = h(k)
$$

Хеш-функция должна быть:

- быстрой,
- распределяющей значения равномерно,
- минимизирующей коллизии.

---

# ## Коллизии

Коллизия возникает, когда:

$$
h(k_1) = h(k_2), \quad k_1 \ne k_2
$$

Существует два основных способа их обработки:

---

## 1. Открытая адресация

При коллизии используется последовательность проб:

### Линейное пробирование:

$$
h_i(k) = (h(k) + i) \bmod m
$$

### Квадратичное пробирование:

$$
h_i(k) = (h(k) + c_1 i + c_2 i^2) \bmod m
$$

### Двойное хеширование:

$$
h_i(k) = (h(k) + i \cdot h'(k)) \bmod m
$$

---

## 2. Метод цепочек (separate chaining)

Каждая ячейка таблицы содержит список (обычно связный):

$$
T[h(k)] = \{k_1, k_2, \dots\}
$$

---

## ## Сложности операций

| Операция        | Среднее | Худшее |
|-----------------|---------|--------|
| Поиск           | \(O(1)\) | \(O(n)\) |
| Вставка         | \(O(1)\) | \(O(n)\) |
| Удаление        | \(O(1)\) | \(O(n)\) |

---

## ## Коэффициент загрузки

$$
\alpha = \frac{n}{m}
$$

где:

- \(n\) — число элементов,
- \(m\) — размер таблицы.

Если \(\alpha\) становится слишком большим → таблицу **рехешируют**:

$$
m_{new} = 2m
$$


