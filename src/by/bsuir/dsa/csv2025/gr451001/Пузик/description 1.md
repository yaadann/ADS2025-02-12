# Название

Сравнение подстрок через хеширование

# Описание

## Условие
Дано `n` строк `s1, s2, ..., sn`. Нужно ответить на `q` запросов вида: равны ли подстроки `si[l1..r1]` и `sj[l2..r2]` (границы — включительно)? Индексация символов в строках — с `1`.
Напишите программу, которая отвечает на все запросы эффективно. В задачах такого типа обычно применяют полиномиальное (rolling) хеширование подстрок. Обратите внимание на вероятность коллизий хешей — чтобы снизить её до приемлемого уровня, используйте две независимые хеш-функции (разные модули и/или базу) или другой способ защиты от коллизий.

## Вход
Первая строка: два целых числа `n` и `q` (`1 ≤ n, q ≤ 2·10^5`).
Далее n строк: `s1, s2, ..., sn`.
Суммарная длина всех строк `∑ |si| ≤ 2·10^6`. Строки содержат только строчные латинские буквы ('a'–'z').
Далее `q` строк — запросы. Каждый запрос задаётся шестью целыми числами:
```
i l1 r1 j l2 r2
```
( `1 ≤ i`, `j ≤ n`, `1 ≤ l1 ≤ r1 ≤ |si|`, `1 ≤ l2 ≤ r2 ≤ |sj|` ).

## Выход
Для каждого запроса выведите в отдельной строке `YES`, если подстроки равны, и `NO` иначе.

# Краткая теория

Полиномиальное хеширование позволяет сравнивать подстроки за *O(1)* после *O(n)* предобработки.
Идея: рассматривать строку как число в некоторой системе счисления по основанию (p) и считать её хеш по модулю (m).

Хеш строки (s = s_1 s_2 \dots s_k):

[
H(s) = \sum_{i=1}^{k} s_i \cdot p^{,i-1} \bmod m.
]

Чтобы эффективно извлекать хеш любой подстроки, используют префиксные хеши:

[
H_{\text{pref}}[i] = \sum_{t=1}^{i} s_t \cdot p^{,t-1} \bmod m.
]

Тогда хеш подстроки (s[l..r]):

[
H(l, r) = \bigl(H_{\text{pref}}[r] - H_{\text{pref}}[l-1] \cdot p^{,r-l+1}\bigr) \bmod m.
]

Сравнение двух подстрок сводится к сравнению их хешей.
Чтобы снизить риск коллизий, применяют двойное хеширование — считают хеши с двумя разными ((p, m)) и сравнивают обе пары значений.

